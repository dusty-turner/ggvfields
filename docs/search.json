[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 ggvfields authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/gallery.html","id":"i--whirlpool","dir":"Articles","previous_headings":"","what":"I. Whirlpool","title":"The Art of Flow: A Visual Gallery","text":"pure rotational field, radial decay draws everything inward. Stream lines spiral toward origin like water draining basin.","code":"whirlpool <- function(v) {   x <- v[1]; y <- v[2]   r <- sqrt(x^2 + y^2) + 0.01   c(-y/r - 0.3*x/r, x/r - 0.3*y/r) }  ggplot() +   geom_stream_field(fun = whirlpool, xlim = c(-3, 3), ylim = c(-3, 3),                     n = 14, L = 1.8, center = TRUE) +   scale_color_gradientn(     colors = c(\"#0d0887\", \"#7e03a8\", \"#cc4778\", \"#f89540\", \"#f0f921\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#0a0a1a\", color = NA))"},{"path":"/articles/gallery.html","id":"ii--sine-waves-in-cross-current","dir":"Articles","previous_headings":"","what":"II. Sine Waves in Cross-Current","title":"The Art of Flow: A Visual Gallery","text":"dx = sin(y) dy = cos(x), result mesmerizing lattice recirculating cells ‚Äì reminiscent Rayleigh‚ÄìB'enard convection.","code":"convection <- function(v) c(sin(v[2]), cos(v[1]))  ggplot() +   geom_stream_field(fun = convection,                     xlim = c(-2*pi, 2*pi), ylim = c(-2*pi, 2*pi),                     n = 12, L = 3, center = TRUE) +   scale_color_gradientn(     colors = c(\"#001219\", \"#005f73\", \"#0a9396\", \"#94d2bd\",                 \"#e9d8a6\", \"#ee9b00\", \"#ca6702\", \"#bb3e03\", \"#9b2226\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#001219\", color = NA))"},{"path":"/articles/gallery.html","id":"iii--twin-galaxies","dir":"Articles","previous_headings":"","what":"III. Twin Galaxies","title":"The Art of Flow: A Visual Gallery","text":"Two competing rotational centers, spiral. influence overlaps, flow distorts braids.","code":"twin_galaxies <- function(v) {   x <- v[1]; y <- v[2]   # Galaxy 1 at (-2, 0)   dx1 <- x + 2; dy1 <- y   r1 <- sqrt(dx1^2 + dy1^2) + 0.1   # Galaxy 2 at (2, 0)   dx2 <- x - 2; dy2 <- y   r2 <- sqrt(dx2^2 + dy2^2) + 0.1   # Spiral: rotation + slight inward pull   u1 <- (-dy1 / r1 - 0.2 * dx1 / r1) * exp(-r1 / 4)   v1 <- ( dx1 / r1 - 0.2 * dy1 / r1) * exp(-r1 / 4)   u2 <- ( dy2 / r2 + 0.2 * dx2 / r2) * exp(-r2 / 4)   v2 <- (-dx2 / r2 + 0.2 * dy2 / r2) * exp(-r2 / 4)   c(u1 + u2, v1 + v2) }  ggplot() +   geom_stream_field(fun = twin_galaxies,                     xlim = c(-6, 6), ylim = c(-5, 5),                     n = 12, L = 3.5, center = TRUE) +   scale_color_gradientn(     colors = c(\"#2d004b\", \"#542788\", \"#8073ac\", \"#b2abd2\",                 \"#f7f7f7\", \"#fdb863\", \"#e08214\", \"#b35806\", \"#7f3b08\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#0d0d1a\", color = NA))"},{"path":"/articles/gallery.html","id":"iv--the-dipole","dir":"Articles","previous_headings":"","what":"IV. The Dipole","title":"The Art of Flow: A Visual Gallery","text":"classic electromagnetic dipole: positive charge negative charge. Field lines arc gracefully source sink. uses built-efield_maker() function.","code":"dipole <- function(v) {   pos <- rbind(c(-1, -1), c(1, 1))   q <- c(-1, 1)   Fx <- 0; Fy <- 0   for (i in 1:2) {     dx <- v[1] - pos[i, 1]; dy <- v[2] - pos[i, 2]     r <- max(sqrt(dx^2 + dy^2), 0.4)     Fx <- Fx + q[i] * dx / r^3     Fy <- Fy + q[i] * dy / r^3   }   mag <- sqrt(Fx^2 + Fy^2)   log(mag + 1) / (mag + 1e-8) * c(Fx, Fy) }  ggplot() +   geom_stream_field(fun = dipole,                     xlim = c(-3, 3), ylim = c(-3, 3),                     n = 12, L = 2, center = TRUE) +   scale_color_gradientn(     colors = c(\"#f7fcf5\", \"#c7e9c0\", \"#74c476\", \"#238b45\", \"#00441b\"),     guide = \"none\"   ) +   annotate(\"point\", x = c(-1, 1), y = c(-1, 1), size = 5,            color = c(\"#e41a1c\", \"#377eb8\")) +   annotate(\"text\", x = c(-1, 1), y = c(-1.4, 1.4),            label = c(\"\\u2212\", \"+\"), size = 8,            color = c(\"#e41a1c\", \"#377eb8\")) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#f7fcf5\", color = NA))"},{"path":"/articles/gallery.html","id":"v--quadrupole-constellation","dir":"Articles","previous_headings":"","what":"V. Quadrupole Constellation","title":"The Art of Flow: A Visual Gallery","text":"Four charges arranged corners square create beautifully symmetric field saddle points intricate flow topology.","code":"quad_field <- function(v) {   charges <- rbind(c(-1.5, -1.5), c(1.5, -1.5), c(-1.5, 1.5), c(1.5, 1.5))   q <- c(1, -1, -1, 1)   efield(v, charges, q, log = TRUE) }  ggplot() +   geom_stream_field(fun = quad_field,                     xlim = c(-4, 4), ylim = c(-4, 4),                     n = 10, L = 2, center = TRUE) +   scale_color_gradientn(     colors = c(\"#440154\", \"#31688e\", \"#35b779\", \"#fde725\"),     guide = \"none\"   ) +   annotate(\"point\",     x = c(-1.5, 1.5, -1.5, 1.5),     y = c(-1.5, -1.5, 1.5, 1.5),     color = c(\"#ff6b6b\", \"#4ecdc4\", \"#4ecdc4\", \"#ff6b6b\"), size = 4   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#1a1a2e\", color = NA))"},{"path":"/articles/gallery.html","id":"vi--vectors-meet-streams","dir":"Articles","previous_headings":"","what":"VI. Vectors Meet Streams","title":"The Art of Flow: A Visual Gallery","text":"field visualized two ways, side side single plot. Vectors show local direction magnitude; streams reveal global flow topology.","code":"saddle_spiral <- function(v) {   x <- v[1]; y <- v[2]   c(x - 0.5*y, -y - 0.5*x) }  ggplot() +   geom_vector_field(fun = saddle_spiral,                     xlim = c(-3, -0.2), ylim = c(-3, 3),                     n = 10) +   geom_stream_field(fun = saddle_spiral,                     xlim = c(0.2, 3), ylim = c(-3, 3),                     n = 10, L = 1.5, center = TRUE) +   annotate(\"text\", x = -1.6, y = -2.8, label = \"Vector Field\",            color = \"grey70\", size = 4, fontface = \"italic\") +   annotate(\"text\", x = 1.6, y = -2.8, label = \"Stream Field\",            color = \"grey70\", size = 4, fontface = \"italic\") +   scale_color_gradientn(     colors = c(\"#2196F3\", \"#E91E63\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#121212\", color = NA))"},{"path":"/articles/gallery.html","id":"vii--topographic-gradient","dir":"Articles","previous_headings":"","what":"VII. Topographic Gradient","title":"The Art of Flow: A Visual Gallery","text":"scalar function defines landscape. gradient points uphill. , potential surface rendered filled contour beneath gradient arrows.","code":"landscape <- function(v) {   x <- v[1]; y <- v[2]   sin(x) * cos(y) + 0.5 * cos(2*x - y) }  ggplot() +   geom_potential(fun = \\(v) c(numDeriv::grad(landscape, v)),                  xlim = c(-pi, pi), ylim = c(-pi, pi), n = 51) +   geom_gradient_field(fun = landscape,                       xlim = c(-pi, pi), ylim = c(-pi, pi),                       n = 12, type = \"vector\") +   scale_fill_gradientn(     colors = c(\"#313695\", \"#4575b4\", \"#74add1\", \"#abd9e9\", \"#e0f3f8\",                 \"#ffffbf\", \"#fee090\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"),     guide = \"none\"   ) +   scale_color_gradientn(     colors = c(\"grey20\", \"grey80\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#313695\", color = NA))"},{"path":"/articles/gallery.html","id":"viii--hexagonal-flow","dir":"Articles","previous_headings":"","what":"VIII. Hexagonal Flow","title":"The Art of Flow: A Visual Gallery","text":"Hexagonal grids break visual monotony rectangular layouts, revealing patterns axis-aligned grids can miss.","code":"shear_rotation <- function(v) {   x <- v[1]; y <- v[2]   c(sin(y + x), cos(x - y)) }  ggplot() +   geom_vector_field(fun = shear_rotation,                     xlim = c(-4, 4), ylim = c(-4, 4),                     grid = \"hex\", n = 14) +   scale_color_gradientn(     colors = c(\"#ff006e\", \"#fb5607\", \"#ffbe0b\", \"#3a86ff\", \"#8338ec\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#0b090a\", color = NA))"},{"path":"/articles/gallery.html","id":"ix--the-lorenz-slice","dir":"Articles","previous_headings":"","what":"IX. The Lorenz Slice","title":"The Art of Flow: A Visual Gallery","text":"Lorenz system lives three dimensions, can slice . Fixing z = 27 (near classic attractor) plotting (x, y) dynamics produces hauntingly beautiful single-wing flow.","code":"lorenz_xy <- function(v, sigma = 10, rho = 28, beta = 8/3, z0 = 27) {   x <- v[1]; y <- v[2]   dx <- sigma * (y - x)   dy <- x * (rho - z0) - y   c(dx, dy) }  ggplot() +   geom_stream_field(fun = lorenz_xy,                     xlim = c(-25, 25), ylim = c(-30, 30),                     n = 12, L = 8, center = TRUE) +   scale_color_gradientn(     colors = c(\"#03071e\", \"#370617\", \"#6a040f\", \"#9d0208\",                 \"#d00000\", \"#dc2f02\", \"#e85d04\", \"#f48c06\",                 \"#faa307\", \"#ffba08\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#03071e\", color = NA))"},{"path":"/articles/gallery.html","id":"x--predator-and-prey","dir":"Articles","previous_headings":"","what":"X. Predator and Prey","title":"The Art of Flow: A Visual Gallery","text":"Lotka‚ÄìVolterra equations describe eternal dance predator prey populations. flow orbits endlessly around equilibrium ‚Äì species wins, species loses.","code":"lotka_volterra <- function(v, alpha = 1.1, beta = 0.4,                            delta = 0.1, gamma = 0.4) {   x <- v[1]; y <- v[2]   dx <- alpha * x - beta * x * y   dy <- delta * x * y - gamma * y   c(dx, dy) }  ggplot() +   geom_stream_field(fun = lotka_volterra,                     xlim = c(0.2, 8), ylim = c(0.2, 6),                     n = 12, L = 2.5, center = TRUE) +   scale_color_gradientn(     colors = c(\"#264653\", \"#2a9d8f\", \"#e9c46a\", \"#f4a261\", \"#e76f51\"),     guide = \"none\"   ) +   annotate(\"point\", x = 4, y = 2.75, size = 4, color = \"white\", shape = 4,            stroke = 1.5) +   labs(x = \"Prey\", y = \"Predator\") +   theme_minimal(base_size = 14) +   theme(     plot.background = element_rect(fill = \"#1d3557\", color = NA),     panel.grid = element_line(color = \"#1d355730\"),     axis.text = element_text(color = \"grey70\"),     axis.title = element_text(color = \"grey80\")   )"},{"path":"/articles/gallery.html","id":"xi--magnitude-as-length","dir":"Articles","previous_headings":"","what":"XI. Magnitude as Length","title":"The Art of Flow: A Visual Gallery","text":"geom_vector_field2() maps norm length rather color, letting see direction magnitude glance without color scale.","code":"stretching <- function(v) {   x <- v[1]; y <- v[2]   c(x * cos(y), y * sin(x)) }  ggplot() +   geom_vector_field2(fun = stretching,                      xlim = c(-pi, pi), ylim = c(-pi, pi),                      n = 16, normalize = FALSE) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#faf9f6\", color = NA))"},{"path":"/articles/gallery.html","id":"xii--smoothing-the-storm","dir":"Articles","previous_headings":"","what":"XII. Smoothing the Storm","title":"The Art of Flow: A Visual Gallery","text":"Real-world data noisy. geom_vector_smooth() fits model ‚Äì GAM ‚Äì recover underlying flow scattered, imperfect measurements.","code":"# Generate noisy observations from a known field set.seed(42) n_obs <- 120 pts <- data.frame(   x = rnorm(n_obs, 0, 1.2),   y = rnorm(n_obs, 0, 1.2) ) true_field <- function(v) c(-v[2], v[1])  # pure rotation pts$fx <- sapply(1:n_obs, \\(i) true_field(c(pts$x[i], pts$y[i]))[1]) + rnorm(n_obs, 0, 1.5) pts$fy <- sapply(1:n_obs, \\(i) true_field(c(pts$x[i], pts$y[i]))[2]) + rnorm(n_obs, 0, 1.5)  ggplot(pts, aes(x = x, y = y, fx = fx, fy = fy)) +   geom_vector_smooth(method = \"gam\", se = TRUE, pi_type = \"wedge\",                      conf_level = 0.90, n = 10) +   geom_vector2(color = \"grey50\", alpha = 0.4) +   scale_color_gradientn(     colors = c(\"#48cae4\", \"#0077b6\", \"#023e8a\"),     guide = \"none\"   ) +   coord_equal() +   labs(title = \"GAM-Smoothed Flow from Noisy Observations\",        subtitle = \"Raw observations shown in grey\") +   theme_minimal(base_size = 13) +   theme(     plot.background = element_rect(fill = \"#caf0f8\", color = NA),     panel.grid = element_line(color = \"#caf0f860\"),     plot.title = element_text(color = \"#023e8a\", face = \"bold\"),     plot.subtitle = element_text(color = \"#0077b6\")   )"},{"path":"/articles/gallery.html","id":"xiii--the-gradient-landscape-with-streams","dir":"Articles","previous_headings":"","what":"XIII. The Gradient Landscape with Streams","title":"The Art of Flow: A Visual Gallery","text":"Instead arrows, trace streams downhill scalar landscape. streams follow negative gradient, pooling basins like rainwater.","code":"peaks <- function(v) {   x <- v[1]; y <- v[2]   3*(1-x)^2 * exp(-x^2 - (y+1)^2) -   10*(x/5 - x^3 - y^5) * exp(-x^2 - y^2) -   1/3 * exp(-(x+1)^2 - y^2) }  neg_grad <- function(v) {   x <- v[1]; y <- v[2]   e1 <- exp(-x^2 - (y + 1)^2)   e2 <- exp(-x^2 - y^2)   e3 <- exp(-(x + 1)^2 - y^2)   dfdx <- 3 * e1 * (-2*(1-x) - 2*x*(1-x)^2) +     -10 * e2 * ((1/5 - 3*x^2) - 2*x*(x/5 - x^3 - y^5)) +     (2/3)*(x+1) * e3   dfdy <- -6*(1-x)^2*(y+1) * e1 +     -10 * e2 * (-5*y^4 - 2*y*(x/5 - x^3 - y^5)) +     (2/3)*y * e3   -c(dfdx, dfdy) }  ggplot() +   geom_potential(fun = \\(v) numDeriv::grad(peaks, v),                  xlim = c(-3, 3), ylim = c(-3, 3), n = 51) +   geom_stream_field(fun = neg_grad,                     xlim = c(-3, 3), ylim = c(-3, 3),                     n = 12, L = 1.5, center = FALSE) +   scale_fill_gradientn(     colors = c(\"#3d0066\", \"#6a0dad\", \"#9b5de5\", \"#f15bb5\",                 \"#fee440\", \"#00f5d4\"),     guide = \"none\"   ) +   scale_color_gradientn(     colors = c(\"white\", \"grey80\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#1a002e\", color = NA))"},{"path":"/articles/gallery.html","id":"xiv--pendulum-phase-portrait","dir":"Articles","previous_headings":"","what":"XIV. Pendulum Phase Portrait","title":"The Art of Flow: A Visual Gallery","text":"simple pendulum rich phase space: closed orbits swinging, open trajectories spinning, saddle points unstable equilibrium. one beautiful objects classical mechanics.","code":"pendulum <- function(v) {   theta <- v[1]; omega <- v[2]   c(omega, -sin(theta)) }  ggplot() +   geom_stream_field(fun = pendulum,                     xlim = c(-2*pi, 2*pi), ylim = c(-3, 3),                     n = 14, L = 2.5, center = TRUE) +   scale_color_gradientn(     colors = c(\"#1b4332\", \"#2d6a4f\", \"#40916c\", \"#52b788\",                 \"#74c69d\", \"#95d5b2\", \"#b7e4c7\", \"#d8f3dc\"),     guide = \"none\"   ) +   labs(x = expression(theta), y = expression(dot(theta))) +   theme_minimal(base_size = 14) +   theme(     plot.background = element_rect(fill = \"#0b1e14\", color = NA),     panel.grid = element_line(color = \"#1b433240\"),     axis.text = element_text(color = \"#74c69d\"),     axis.title = element_text(color = \"#95d5b2\", size = 16)   )"},{"path":"/articles/gallery.html","id":"xv--stained-glass","dir":"Articles","previous_headings":"","what":"XV. Stained Glass","title":"The Art of Flow: A Visual Gallery","text":"vector fields simply beautiful sake. physics required ‚Äì just mathematics painting color.","code":"stained <- function(v) {   x <- v[1]; y <- v[2]   c(sin(x*y) + cos(y^2), cos(x^2) - sin(x*y)) }  ggplot() +   geom_stream_field(fun = stained,                     xlim = c(-3, 3), ylim = c(-3, 3),                     n = 14, L = 2, center = TRUE) +   scale_color_gradientn(     colors = c(\"#ff0a54\", \"#ff477e\", \"#ff7096\", \"#ff85a1\",                 \"#fbb1bd\", \"#f9bec7\", \"#ff85a1\", \"#ff477e\",                 \"#ff0a54\", \"#c9184a\", \"#a4133c\", \"#800f2f\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#fff0f3\", color = NA))"},{"path":"/articles/gallery.html","id":"xvi--five-charge-constellation","dir":"Articles","previous_headings":"","what":"XVI. Five-Charge Constellation","title":"The Art of Flow: A Visual Gallery","text":"arrangement five alternating charges creates symmetric field rich topology ‚Äì visual reminiscent aurora borealis.","code":"five_charge <- function(v) {   # Pentagon arrangement   angles <- seq(0, 2*pi, length.out = 6)[-6]   r <- 2.5   charges <- cbind(r * cos(angles), r * sin(angles))   q <- c(1, -1, 1, -1, 1)   efield(v, charges, q, log = TRUE) }  ggplot() +   geom_stream_field(fun = five_charge,                     xlim = c(-5, 5), ylim = c(-5, 5),                     n = 10, L = 2, center = TRUE) +   scale_color_gradientn(     colors = c(\"#0d1b2a\", \"#1b263b\", \"#415a77\", \"#778da9\", \"#e0e1dd\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#0d1b2a\", color = NA))"},{"path":"/articles/gallery.html","id":"xvii--layered-potential-vectors-streams","dir":"Articles","previous_headings":"","what":"XVII. Layered: Potential + Vectors + Streams","title":"The Art of Flow: A Visual Gallery","text":"expressive plots combine multiple layers. potential surface, vector arrows, stream lines work together.","code":"conservative <- function(v) {   x <- v[1]; y <- v[2]   c(2*x, 2*y)  # gradient of x^2 + y^2 }  ggplot() +   geom_potential(fun = conservative,                  xlim = c(-3, 3), ylim = c(-3, 3), n = 51) +   geom_vector_field(fun = conservative,                     xlim = c(-3, 3), ylim = c(-3, 3),                     n = 8, arrow = arrow(length = unit(0.15, \"cm\"))) +   geom_stream_field(fun = conservative,                     xlim = c(-3, 3), ylim = c(-3, 3),                     n = 12, L = 1.5, center = FALSE,                     color = \"white\", alpha = 0.3) +   scale_fill_gradientn(     colors = c(\"#000004\", \"#1b0c41\", \"#4a0c6b\", \"#781c6d\",                 \"#a52c60\", \"#cf4446\", \"#ed6925\", \"#fb9b06\",                 \"#f7d13d\", \"#fcffa4\"),     guide = \"none\"   ) +   scale_color_gradientn(     colors = c(\"#fcffa4\", \"#fb9b06\", \"#cf4446\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#000004\", color = NA))"},{"path":"/articles/gallery.html","id":"xviii--van-der-pol-limit-cycle","dir":"Articles","previous_headings":"","what":"XVIII. Van der Pol Limit Cycle","title":"The Art of Flow: A Visual Gallery","text":"Van der Pol oscillator relaxes stable limit cycle ‚Äì lone closed orbit swallows every nearby trajectory. pink--cyan gradient traces streamline‚Äôs arc spirals inward outward toward cycle.","code":"van_der_pol <- function(v, mu = 1.5) {   x <- v[1]; y <- v[2]   c(y, mu * (1 - x^2) * y - x) }  ggplot() +   geom_stream_field(fun = van_der_pol,                     xlim = c(-4, 4), ylim = c(-6, 6),                     n = 12, L = 4) +   scale_color_gradientn(     colors = c(\"#f72585\", \"#b5179e\", \"#7209b7\", \"#560bad\",                \"#480ca8\", \"#3a0ca3\", \"#3f37c9\", \"#4361ee\",                \"#4895ef\", \"#4cc9f0\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#10002b\", color = NA))"},{"path":"/articles/gallery.html","id":"xix--flow-past-a-cylinder","dir":"Articles","previous_headings":"","what":"XIX. Flow Past a Cylinder","title":"The Art of Flow: A Visual Gallery","text":"Potential flow around circular obstacle ‚Äì canonical illustration inviscid fluid dynamics. Streamlines compress fluid accelerates past cylinder‚Äôs shoulders.","code":"cylinder_flow <- function(v, R = 1, U = 1) {   x <- v[1]; y <- v[2]   r2 <- x^2 + y^2   if (r2 < R^2) return(c(0, 0))   r4 <- r2^2   u <- U * (1 - R^2 * (x^2 - y^2) / r4)   w <- -U * 2 * R^2 * x * y / r4   c(u, w) }  theta_cyl <- seq(0, 2 * pi, length.out = 200) cyl <- data.frame(x = cos(theta_cyl), y = sin(theta_cyl))  ggplot() +   geom_stream_field(fun = cylinder_flow,                     xlim = c(-4, 4), ylim = c(-3, 3),                     n = 14, L = 3, center = FALSE) +   geom_polygon(data = cyl, aes(x = x, y = y),                fill = \"#2b2d42\", color = \"#8d99ae\", linewidth = 0.5) +   scale_color_gradientn(     colors = c(\"#caf0f8\", \"#90e0ef\", \"#00b4d8\", \"#0077b6\", \"#03045e\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#03045e\", color = NA))"},{"path":"/articles/gallery.html","id":"xx--the-duffing-double-well","dir":"Articles","previous_headings":"","what":"XX. The Duffing Double Well","title":"The Art of Flow: A Visual Gallery","text":"Two stable equilibria flanking unstable saddle. Trajectories loop around one well ‚Äì , enough energy, orbit . portrait bistability.","code":"duffing <- function(v) {   x <- v[1]; y <- v[2]   c(y, x - x^3 - 0.15 * y) }  ggplot() +   geom_stream_field(fun = duffing,                     xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5),                     n = 14, L = 3, center = TRUE) +   annotate(\"point\", x = c(-1, 0, 1), y = c(0, 0, 0),            color = c(\"#06d6a0\", \"#ef476f\", \"#06d6a0\"),            size = c(3, 4, 3), shape = c(16, 4, 16)) +   scale_color_gradientn(     colors = c(\"#073b4c\", \"#118ab2\", \"#06d6a0\", \"#ffd166\", \"#ef476f\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#073b4c\", color = NA))"},{"path":"/articles/gallery.html","id":"xxi--smoothed-streamlines-from-noisy-measurements","dir":"Articles","previous_headings":"","what":"XXI. Smoothed Streamlines from Noisy Measurements","title":"The Art of Flow: A Visual Gallery","text":"Real sensors give noisy readings. geom_stream_smooth() fits model scattered vector observations integrates predicted field clean streamlines ‚Äì recovering true flow imperfect data.","code":"set.seed(123) n_obs <- 150 pts_ss <- data.frame(   x = runif(n_obs, -3, 3),   y = runif(n_obs, -3, 3) ) # True field: a saddle with rotation true_flow <- function(v) c(v[1] - 0.5 * v[2], -v[2] + 0.5 * v[1]) pts_ss$fx <- sapply(1:n_obs, \\(i) true_flow(c(pts_ss$x[i], pts_ss$y[i]))[1]) +   rnorm(n_obs, 0, 0.8) pts_ss$fy <- sapply(1:n_obs, \\(i) true_flow(c(pts_ss$x[i], pts_ss$y[i]))[2]) +   rnorm(n_obs, 0, 0.8)  ggplot(pts_ss, aes(x = x, y = y, fx = fx, fy = fy)) +   geom_stream_smooth(method = \"gam\", n = 10, L = 1.5, center = TRUE) +   geom_vector2(color = \"#d8f3dc\", alpha = 0.25) +   scale_color_gradientn(     colors = c(\"#52b788\", \"#40916c\", \"#2d6a4f\", \"#1b4332\", \"#081c15\"),     guide = \"none\"   ) +   coord_equal() +   labs(title = \"GAM-Smoothed Streamlines\",        subtitle = \"Raw noisy observations shown as faint arrows\") +   theme_minimal(base_size = 13) +   theme(     plot.background = element_rect(fill = \"#081c15\", color = NA),     panel.grid = element_line(color = \"#1b433220\"),     plot.title = element_text(color = \"#95d5b2\", face = \"bold\"),     plot.subtitle = element_text(color = \"#52b788\"),     axis.text = element_blank(),     axis.title = element_blank()   )"},{"path":"/articles/gallery.html","id":"xxii--sculpted-terrain","dir":"Articles","previous_headings":"","what":"XXII. Sculpted Terrain","title":"The Art of Flow: A Visual Gallery","text":"Given scattered elevation readings, geom_gradient_smooth() fits surface draws gradient ‚Äì arrows pointing uphill, tracing steepest ascent across landscape can almost feel underfoot.","code":"set.seed(7) terrain <- data.frame(   x = runif(300, -3, 3),   y = runif(300, -3, 3) ) terrain$z <- with(terrain,   2 * exp(-((x - 1)^2 + (y - 1)^2)) -   1.5 * exp(-((x + 1.5)^2 + (y + 1)^2) / 2) +   0.2 * rnorm(300) )  # Fit the surface and predict on a grid for the background fit <- lm(z ~ poly(x, 4) * poly(y, 4), data = terrain) bg_grid <- expand.grid(   x = seq(-3, 3, length.out = 80),   y = seq(-3, 3, length.out = 80) ) bg_grid$z <- predict(fit, bg_grid)  ggplot(terrain, aes(x = x, y = y, z = z)) +   geom_raster(data = bg_grid, aes(x = x, y = y, fill = z), inherit.aes = FALSE) +   geom_gradient_smooth(     formula = z ~ poly(x, 4) * poly(y, 4),     n = 10, type = \"vector\"   ) +   scale_fill_gradientn(     colors = c(\"#283618\", \"#606c38\", \"#a3b18a\", \"#fefae0\", \"#dda15e\", \"#bc6c25\"),     guide = \"none\"   ) +   scale_color_gradientn(     colors = c(\"grey20\", \"grey90\"),     guide = \"none\"   ) +   coord_equal() +   labs(title = \"Gradient of Smoothed Elevation\",        subtitle = \"Arrows point uphill across a fitted terrain surface\") +   theme_minimal(base_size = 13) +   theme(     plot.background = element_rect(fill = \"#1a1a0e\", color = NA),     panel.grid = element_line(color = \"#28361820\"),     plot.title = element_text(color = \"#fefae0\", face = \"bold\"),     plot.subtitle = element_text(color = \"#dda15e\"),     axis.text = element_text(color = \"#606c38\"),     axis.title = element_blank()   )"},{"path":"/articles/gallery.html","id":"xxiii--magnitude-by-length","dir":"Articles","previous_headings":"","what":"XXIII. Magnitude by Length","title":"The Art of Flow: A Visual Gallery","text":"geom_vector_field2() encodes magnitude arrow length rather color. Paired scale_length_continuous(), get fine control loudly region field speaks.","code":"source_sink <- function(v) {   x <- v[1]; y <- v[2]   r1 <- sqrt((x - 1.5)^2 + y^2) + 0.1   r2 <- sqrt((x + 1.5)^2 + y^2) + 0.1   c((x - 1.5) / r1^2 - (x + 1.5) / r2^2,     y / r1^2 - y / r2^2) }  ggplot() +   geom_vector_field2(fun = source_sink,                      xlim = c(-4, 4), ylim = c(-4, 4),                      n = 16, normalize = FALSE) +   scale_length_continuous(max_range = 0.4) +   annotate(\"point\", x = c(-1.5, 1.5), y = c(0, 0),            color = c(\"#9b2226\", \"#005f73\"), size = 5) +   annotate(\"text\", x = c(-1.5, 1.5), y = c(-0.7, -0.7),            label = c(\"sink\", \"source\"),            color = c(\"#9b2226\", \"#005f73\"), size = 4, fontface = \"italic\") +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#faf9f6\", color = NA))"},{"path":"/articles/gallery.html","id":"xxiv--hand-spun-spirals","dir":"Articles","previous_headings":"","what":"XXIV. Hand-Spun Spirals","title":"The Art of Flow: A Visual Gallery","text":"every stream comes differential equation. geom_stream() renders ordered set points flowing curve time-parameterised color ‚Äì perfect custom, procedurally generated, hand-crafted data.","code":"make_spiral <- function(id, cx, cy, dir = 1, n_pts = 150) {   s <- seq(0, 5 * pi, length.out = n_pts)   r <- 0.05 + s / (5 * pi) * 2   data.frame(     x = cx + r * cos(dir * s),     y = cy + r * sin(dir * s),     t = seq(0, 1, length.out = n_pts),     id = id   ) }  spirals <- do.call(rbind, list(   make_spiral(1,  0,    0,    1),   make_spiral(2, -2.5,  2.5, -1),   make_spiral(3,  2.5, -2.5,  1),   make_spiral(4, -2.5, -2.5,  1),   make_spiral(5,  2.5,  2.5, -1),   make_spiral(6,  0,    3,   -1),   make_spiral(7,  0,   -3,    1),   make_spiral(8, -3,    0,    1),   make_spiral(9,  3,    0,   -1) ))  ggplot(spirals, aes(x = x, y = y, t = t, group = id)) +   geom_stream(linewidth = 0.6) +   scale_color_gradientn(     colors = c(\"#ffd6ff\", \"#e7c6ff\", \"#c8b6ff\", \"#b8c0ff\", \"#bbd0ff\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#10002b\", color = NA))"},{"path":"/articles/gallery.html","id":"xxv--complex-cosine","dir":"Articles","previous_headings":"","what":"XXV. Complex Cosine","title":"The Art of Flow: A Visual Gallery","text":"Map complex-valued function 2D vector field: point z = x + iy, vector real imaginary parts cos(z). zeros cosine become fixed points, field weaves tapestry hyperbolic arcs ‚Äì complex analysis made visible.  plots built handful lines ‚Äì power ggvfields. Define function, choose geometry, pick colors, let mathematics flow.","code":"cos_field <- function(v) {   x <- v[1]; y <- v[2]   c(cos(x) * cosh(y), -sin(x) * sinh(y)) }  ggplot() +   geom_stream_field(fun = cos_field,                     xlim = c(-2 * pi, 2 * pi), ylim = c(-3, 3),                     n = 14, L = 2, center = TRUE) +   scale_color_gradientn(     colors = c(\"#001427\", \"#708d81\", \"#f4d58d\", \"#bf0603\", \"#8d0801\"),     guide = \"none\"   ) +   coord_equal() +   theme_void() +   theme(plot.background = element_rect(fill = \"#001427\", color = NA))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dusty Turner. Author, maintainer. David Kahle. Author. Rodney X. Sturdivant. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Turner D, Kahle D, Sturdivant R (2026). ggvfields: Vector Field Visualizations 'ggplot2'. R package version 1.0.0, https://github.com/dusty-turner/ggvfields.","code":"@Manual{,   title = {ggvfields: Vector Field Visualizations with 'ggplot2'},   author = {Dusty Turner and David Kahle and Rodney X. Sturdivant},   year = {2026},   note = {R package version 1.0.0},   url = {https://github.com/dusty-turner/ggvfields}, }"},{"path":"/index.html","id":"ggvfields-","dir":"","previous_headings":"","what":"Vector Field Visualizations with ggplot2","title":"Vector Field Visualizations with ggplot2","text":"ggvfields extends ggplot2 providing suite tools visualize vector stream fields. addition standard vector stream plotting, ggvfields automatically computes visualizes smoothed vector fields, smooth gradient fields, gradient fields derived scalar functions, potential fields gradients. integrated framework simplifies analysis interpretation complex vector scalar field data. manuscript describing theoretical foundations detailed methodologies behind ggvfields forthcoming.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Vector Field Visualizations with ggplot2","text":"ggvfields available CRAN can installed : Alternatively, can install latest development version GitHub : Load package R:","code":"install.packages(\"ggvfields\") remotes::install_github(\"dusty-turner/ggvfields\") library(\"ggvfields\") #> Loading required package: ggplot2 options(ggplot2.continuous.colour=\"viridis\")"},{"path":[]},{"path":"/index.html","id":"geom_vector_field-and-geom_vector_field2","dir":"","previous_headings":"Core Features","what":"geom_vector_field() and geom_vector_field2()","title":"Vector Field Visualizations with ggplot2","text":"geom_vector_field(): Computes vector fields user-defined function domain {(x,y)‚àà‚Ñù2:‚àí1<x<1,‚àí1<y<1}\\{(x,y) \\\\mathbb{R}^2 : -1 < x < 1,\\ -1 < y < 1\\} n√ónn \\times n grid (default: 11√ó1111 \\times 11) maps norm color. Vectors centered normalized default. norm ùê∞=(u,v)\\mathbf{w} = (u, v) calculated |ùê∞|=u2+v2|\\mathbf{w}| = \\sqrt{u^2 + v^2} .  geom_vector_field2(): Similar geom_vector_field(), maps norm vectors lengths instead color.  Length Mapping Matters Mapping vector lengths norms allows viewers immediately understand magnitude differences without relying solely color. feature geom_vector2() enhances interpretability using actual vector lengths represent magnitude. legend reflects scaling ensures correct interpretation. geom_vector_field() options Length can set L parameter visualize vectors specified length.  Center default, vectors centered origin. can turn centering.  normalize turn normalization centering, get raw look vector field data.","code":"f <- function(v) c(-v[2], v[1]) # Define a function for the field  ggplot() +   geom_vector_field(fun = f) ggplot() +   geom_vector_field2(fun = f) ggplot() +   geom_vector_field(fun = f, n = 4, L = 2) ggplot() +   geom_vector_field(fun = f, n = 4, center = FALSE) ggplot() +   geom_vector_field(fun = f, n = 4, normalize = FALSE, center = FALSE)"},{"path":"/index.html","id":"geom_stream_field-and-geom_stream_field2","dir":"","previous_headings":"Core Features","what":"geom_stream_field() and geom_stream_field2()","title":"Vector Field Visualizations with ggplot2","text":"geom_stream_field(): Computes stream fields user-defined function maps average speed color. Average speed overall rate particle traverses shown stream. displacement vector length |ùêù||\\mathbf{d}| takes time tt, integration time streams, traverse distance, average speed given Average Speed=|ùêù|t\\text{Average Speed} = \\frac{|\\mathbf{d}|}{t}  geom_stream_field2(): Similar geom_stream_field(), removes mapping, arrow heads, designates stream origins dot.  geom_stream_field() options geom_stream_field() maintains similar options geom_vector_field(). arguments yield slightly different behavior. Length adjusting L parameter, can control length stream.  Normalization default, lengths stream normalized length. turning normalization , stream becomes time normalized. words, stream grows amount time.  can control length longest stream normalize = FALSE altering L argument.  Time normalize = FALSE, can grow stream amount time using T parameter.","code":"ggplot() +   geom_stream_field(fun = f) ggplot() +   geom_stream_field2(fun = f) ggplot() +   geom_stream_field(fun = f, n = 4, L = .8) ggplot() +   geom_stream_field(fun = f, n = 4, normalize = FALSE) ggplot() +   geom_stream_field(fun = f, n = 4, normalize = FALSE, L = .8) ggplot() +   geom_stream_field(fun = f, n = 4, normalize = FALSE, T = .5)"},{"path":"/index.html","id":"geom_gradient_field-and-geom_gradient_field2","dir":"","previous_headings":"Core Features","what":"geom_gradient_field() and geom_gradient_field2()","title":"Vector Field Visualizations with ggplot2","text":"geom_gradient_field() function computes visualizes gradient fields derived scalar functions displays gradient vector field scalar function, f(x,y)f(x, y). gradient given : ‚àáf(x,y)=(‚àÇf‚àÇx,‚àÇf‚àÇy) \\nabla f(x, y) = \\left( \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y} \\right) vector field points direction greatest rate increase scalar function. function numerically evaluates partial derivatives visualizes resulting vectors. Gradient Fields Vectors resulting vector field defaults options geom_vector_field()  Gradient Fields Streams resulting stream field defaults options geom_stream_field()","code":"field <- function(v) {   x <- v[1]   y <- v[2]   x^3 + y^3 }  ggplot() +   geom_gradient_field(fun = field) ggplot() +   geom_gradient_field(fun = field, type = \"stream\")"},{"path":"/index.html","id":"geom_potential","dir":"","previous_headings":"Core Features","what":"geom_potential()","title":"Vector Field Visualizations with ggplot2","text":"potential function represents scalar field whose gradient produces vector field. used describe conservative vector fields exist curl vector field 0. geom_potential() function computes visualizes scalar potential function given conservative vector field. input function must represent 2D vector field output corresponding potential function. input field conservative, function checks condition numerically based tolerance parameter. tolerance determines strictly field must satisfy conservation condition.  tol parameter can adjusted control sensitivity conservativeness check. Decreasing tolerance makes check stricter, increasing allows numerical error. can turn functionality verify_conservative = TRUE.","code":"conservative_fun <- function(v) {  x <- v[1]  y <- v[2]  c(sin(x) + y, x - sin(y)) }  ggplot() +   geom_potential(fun = conservative_fun, xlim = c(-2*pi, 2*pi), ylim = c(-2*pi, 2*pi)) non_conservative_fun <- function(v) {  x <- v[1]  y <- v[2]  c(-y, x) }  ggplot() +   geom_potential(fun = non_conservative_fun,                   xlim = c(-2*pi, 2*pi), ylim = c(-2*pi, 2*pi),                   verify_conservative = TRUE,                  tol = 1e-6                  ) #> Warning: ! The provided vector field does not have a potential function everywhere #>   within the specified domain. #> ‚Üí Ensure that the vector field satisfies the necessary conditions for a #>   potential function."},{"path":"/index.html","id":"geom_vector-and-geom_vector2","dir":"","previous_headings":"Core Features","what":"geom_vector() and geom_vector2()","title":"Vector Field Visualizations with ggplot2","text":"far, layers supported visualizing functions. ggvfields can also visualize raw data. Generate sample wind data: geom_vector(): default, maps norm (magnitude) vector color.  geom_vector() also supports xend/yend format well fx/fy format.  geom_vector2(): Maps norm vector directly length. provides intuitive representation magnitude. done mapping length = after_stat(norm) default.  Polar Coordinates Support geom_vector() geom_vector2() also support polar coordinates, vectors specified using magnitude (distance) direction (angle). Instead providing Cartesian components (fx, fy xend, yend), users can directly supply polar data. feature simplifies workflows directional data works subsequent relevant functions handle polar coordinates. Polar coordinates can visualized like :  Normalize Center normalize: set TRUE, option scales vector unit length, can help avoid overplotting dense vector fields. especially useful direction vectors important magnitude. However, ‚Äôs important note normalize different mapping norm vector length aesthetic. normalization ensures vectors visually uniform length, mapping norm length preserves relative differences magnitude varying vector lengths based actual norms. center: default, center also set TRUE, meaning midpoint vector placed corresponding (x, y) coordinate, effectively ‚Äúcentering‚Äù vector point. center FALSE, base vector anchored (x, y) point, vector extends outward . example turns default behavior:","code":"set.seed(1234) n <- 10  wind_data <- data.frame(   lon = rnorm(n),    lat = rnorm(n),    dir = runif(n, -pi/2, pi/2),   spd = rchisq(n, df = 2) ) |>    within({     fx    <- spd * cos(dir)          # Compute the x-component of the vector     fy    <- spd * sin(dir)          # Compute the y-component of the vector     xend  <- lon + fx                # Compute the end x-coordinate     yend  <- lat + fy                # Compute the end y-coordinate   })  round(wind_data, digits = 2) |> head(6) #>     lon   lat   dir   spd  yend xend    fy    fx #> 1 -1.21 -0.48  0.17  3.55  0.11 2.29  0.59  3.50 #> 2  0.28 -1.00  0.46  2.19 -0.03 2.24  0.97  1.96 #> 3  1.08 -0.78 -0.59  2.99 -2.44 3.56 -1.66  2.48 #> 4 -2.35  0.06  0.38 10.81  4.10 7.68  4.04 10.03 #> 5  0.43  0.96 -0.53  3.45 -0.80 3.40 -1.76  2.97 #> 6  0.51 -0.11  0.01  3.91 -0.09 4.41  0.02  3.91 ggplot(wind_data) +   geom_vector(aes(x = lon, y = lat, xend = xend, yend = yend)) ggplot(wind_data) +   geom_vector(aes(x = lon, y = lat, fx = fx, fy = fy)) ggplot(wind_data) +   geom_vector2(aes(x = lon, y = lat, fx = fx, fy = fy)) ggplot(wind_data) +   geom_vector(aes(x = lon, y = lat, distance = spd, angle = dir)) ggplot(wind_data) +   geom_vector(aes(x = lon, y = lat, fx = fx, fy = fy), center = FALSE, normalize = FALSE)"},{"path":"/index.html","id":"modeling-features","dir":"","previous_headings":"","what":"Modeling Features","title":"Vector Field Visualizations with ggplot2","text":"ggvfields offers techniques smoothing noisy vector field data geom_stream_smooth() geom_vector_smooth() geom_stream_smooth() uses dynamical systems approach geom_vector_smooth() offers multivariate regression approach accounts uncertainty.","code":""},{"path":"/index.html","id":"geom_stream_smooth","dir":"","previous_headings":"Modeling Features","what":"geom_stream_smooth()","title":"Vector Field Visualizations with ggplot2","text":"","code":"ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector(alpha = .5, color = \"black\") +   geom_stream_smooth(aes(x = lon, y = lat, fx = fx, fy = fy))"},{"path":"/index.html","id":"geom_vector_smooth","dir":"","previous_headings":"Modeling Features","what":"geom_vector_smooth()","title":"Vector Field Visualizations with ggplot2","text":"Provides smoothed estimates vector fields applying statistical techniques observed vectors. Smoothing performed using multivariate linear model defined : (dxÃÇdyÃÇ)=Œ≤0+Œ≤1x+Œ≤2y+Œ≤3xy \\begin{pmatrix} \\hat{dx} \\\\ \\hat{dy} \\end{pmatrix} = \\beta_0 + \\beta_1 x + \\beta_2 y + \\beta_3 xy Œ≤\\beta coefficients estimated ordinary least squares (OLS). approach captures linear interaction effects approximate underlying vector field. function also creates prediction interval around vector specified conf_level argument defaults .95. Evaluating Specific Points: evaluation points provided, smoothing performed locations prediction intervals can visualized using either wedges ellipses indicate uncertainty.  Using Wedges Visualize Uncertainty:  Grid-Based Smoothing:  Custom Grid Resolution:  Altering Confidence Level options, can change confidence level default another value using conf_level argument.","code":"eval_point <- data.frame(x = .5, y = .5)   ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector(normalize = FALSE) +   geom_vector_smooth(eval_points = eval_point) +   lims(x = c(-7,10), y = c(-3,3)) #> Warning: Removed 2 rows containing missing values or values outside the scale range #> (`geom_stream()`). ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector(normalize = FALSE) +   geom_vector_smooth(eval_points = eval_point, pi_type = \"wedge\") ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector_smooth(pi_type = \"wedge\") +    geom_vector() ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector_smooth(n = 6, pi_type = \"wedge\") ggplot(wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector(normalize = FALSE) +   geom_vector_smooth(eval_points = eval_point, pi_type = \"wedge\") +   geom_vector_smooth(eval_points = eval_point, pi_type = \"wedge\", conf_level = .7)"},{"path":"/index.html","id":"geom_gradient_smooth","dir":"","previous_headings":"Modeling Features","what":"geom_gradient_smooth()","title":"Vector Field Visualizations with ggplot2","text":"geom_gradient_smooth() creates smoothed gradient field raw scalar data using fitted linear model. function estimates gradients scalar values (z) observed spatial locations (x, y). designed cases scalar data wish estimate gradient. gradients computed numerically fitted scalar field model resulting gradient vectors visualized using either streamlines vector arrows.  illustrate geom_gradient_smooth() can adapt nonlinear surfaces, can change formula used fit scalar field switch streamline visualization using type = \"stream\". example uses smooth noisy scalar function generates curved gradients fits flexible smoothing model capture variations.","code":"f1 <- function(u) {   x <- u[1]   y <- u[2]   x^2 - y^2 }  grid_data <- expand.grid(   x = seq(-5, 5, length.out = 30),   y = seq(-5, 5, length.out = 30) )  set.seed(123) grid_data$z <- apply(grid_data, 1, f1) + rnorm(nrow(grid_data), mean = 0, sd = 5)  ggplot(grid_data, aes(x = x, y = y, z = z)) +   geom_gradient_smooth() h1 <- function(u) {   x <- u[1]   y <- u[2]   sin(x / 2) * cos(y / 2) }  grid_data$z <- apply(grid_data, 1, h1) + rnorm(nrow(grid_data), mean = 0, sd = 1)  ggplot(grid_data, aes(x = x, y = y, z = z)) +   geom_gradient_smooth(formula = z ~ I(x^2) * I(y^2), n = 5, type = \"stream\")"},{"path":[]},{"path":"/index.html","id":"automatic-limit-detection","dir":"","previous_headings":"Other Features","what":"Automatic Limit Detection","title":"Vector Field Visualizations with ggplot2","text":"functions can automatically determine plot limits based function provided. happens data exists previous layers base ggplot object. allows limits inferred context. Customize limits xlim ylim parameters needed control.","code":"ggplot(data = wind_data, aes(x = lon, y = lat, fx = fx, fy = fy)) +   geom_vector() +   geom_stream_field(fun = f) # Automatically determines limits based on existing data"},{"path":"/index.html","id":"custom-grids","dir":"","previous_headings":"Other Features","what":"Custom Grids","title":"Vector Field Visualizations with ggplot2","text":"geom_*_field functions allow user plot custom evaluation locations. user can specify specific points evaluated field can also use ‚Äúhex‚Äù pattern.  shows custom grid.","code":"ggplot() +   geom_stream_field(fun = f, grid = \"hex\") custom <- data.frame(x = c(1,3,5), y = c(3,4,5))  ggplot() +   geom_stream_field(fun = f, grid = custom, normalize = FALSE, center = FALSE, L = 4)"},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Vector Field Visualizations with ggplot2","text":"package licensed MIT License.","code":""},{"path":"/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"Vector Field Visualizations with ggplot2","text":"questions feedback, please open issue.","code":""},{"path":"/index.html","id":"related-projects","dir":"","previous_headings":"","what":"Related Projects","title":"Vector Field Visualizations with ggplot2","text":"metR: Meteorological visualizations tools vector fields. ggfields: Vector field layers similar geom_spoke. ggquiver: Quiver plots vector fields. ggarchery: Arrow segment visualizations.","code":""},{"path":"/reference/efield.html","id":null,"dir":"Reference","previous_headings":"","what":"Electric field ‚Äî efield","title":"Electric field ‚Äî efield","text":"vector field generated collection fixed electrical charges, dictated Coulomb's law. function mainly used provide examples visualizing vector fields ggvfields.","code":""},{"path":"/reference/efield.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Electric field ‚Äî efield","text":"","code":"efield(u, charge_positions, charges, k = 1, q_test = +1, log = FALSE)  efield_maker(   charge_positions = rbind(c(-1, -1), c(1, 1)),   charges = c(-1, +1),   k = 1,   q_test = +1,   log = FALSE )"},{"path":"/reference/efield.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Electric field ‚Äî efield","text":"u position test charge. charge_positions positions fixed charges generating electric field. Defaulted efield_maker(). charges charges points placed positions charge_positions. Defaulted efield_maker(). k constant proportionality, defaulted 1. See examples rigorous use physical constants. q_test test charge, defaulted +1. log Executes transformation double log norm vectors.","code":""},{"path":"/reference/efield.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Electric field ‚Äî efield","text":"vector containing force felt test charge account electric field.","code":""},{"path":[]},{"path":"/reference/efield.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Electric field ‚Äî efield","text":"","code":"if (FALSE) { # \\dontrun{ # set a - charge at (-1,-1) and a + charge at (1,1) charge_positions <- rbind(c(-1,-1), c(1,1)) charges <- c(-1, +1)   # calculate force on test charge (+1) at c(0,1), ignoring physical constants efield(c(0,1), charge_positions, charges)   # efield_maker() simply wraps this function, defaulting to those charges f <- efield_maker() f(c(0,1))  ggplot() +   geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +   scale_color_viridis_c(trans = \"log10\")  # electric constant from https://en.wikipedia.org/wiki/Vacuum_permittivity ep0 <- 8.854187818814e-12 k <- (4*pi*ep0)^-1 efield(c(0,1), charge_positions, charges, k) } # }"},{"path":"/reference/geom_gradient_field.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"functions provide convenient ggplot2 layers drawing gradient fields computing gradient scalar field. user-defined function (fun) specifies behavior scalar field taking numeric vector length 2 (representing \\((x, y)\\)) returning single numeric value. underlying StatStreamField computes gradient via numerical differentiation (using numDeriv::grad()) GeomStream renders resulting vectors.","code":""},{"path":"/reference/geom_gradient_field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"","code":"geom_gradient_field(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = TRUE,   type = \"vector\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = grid::unit(0.02, \"npc\"), type = \"closed\") )  stat_gradient_field(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = TRUE,   type = \"vector\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = grid::unit(0.02, \"npc\"), type = \"closed\") )  geom_gradient_field2(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = FALSE,   type = \"stream\",   normalize = TRUE,   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL )  stat_gradient_field2(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = FALSE,   type = \"stream\",   normalize = TRUE,   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL )"},{"path":"/reference/geom_gradient_field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"mapping set aesthetic mappings created ggplot2::aes(). Additional aesthetics color, size, linetype, alpha can defined. geom_gradient_field default mapping includes color = after_stat(norm), whereas geom_gradient_field2 default mapping includes length = after_stat(norm). data data frame containing input data. stat statistical transformation use data layer. Defaults StatStreamField. position Position adjustment, either string result position adjustment function. ... arguments passed grid::layer(). na.rm Logical. FALSE (default), missing values removed warning. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . fun function defines scalar field. take numeric vector length 2 (representing \\((x, y)\\)) return single numeric value. (Required) xlim Numeric vector length two. Specifies limits x-axis domain. Defaults c(-1, 1). ylim Numeric vector length two. Specifies limits y-axis domain. Defaults c(-1, 1). n Integer. Grid resolution specifying number seed points along axis. Higher values produce denser gradient field. Defaults 11. max_it Integer. Maximum number integration steps allowed computing gradient stream. Defaults 1000. T Numeric. Time increment used numerical integration normalize FALSE. provided, computed automatically based grid spacing vector field‚Äôs magnitude. L Numeric. Target length gradient vectors streamlines. normalize TRUE, computed vectors scaled length L. provided, L computed automatically grid spacing. center Logical. TRUE, centers seed points original (x, y) becomes midpoint. type Character. Specifies type field compute: use \"stream\" generate integrated streamlines \"vector\" individual vector segments. Defaults \"stream\". normalize Logical. TRUE, gradient vectors normalized based grid spacing. Defaults TRUE. tail_point Logical. TRUE, point drawn tail gradient vector. eval_point Logical. TRUE, point drawn evaluation point gradient computed. Defaults FALSE. grid data frame containing precomputed grid points seed placement. NULL (default), regular Cartesian grid generated based xlim, ylim, n. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow grid::arrow() specification add arrowheads gradient vectors. geom_gradient_field, default closed arrow 30¬∞ angle length 0.02 npc; geom_gradient_field2(), default NULL. geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_gradient_field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"ggplot2 layer computes plots gradient field numerically differentiating scalar field.","code":""},{"path":"/reference/geom_gradient_field.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"Two variants provided: geom_gradient_field() uses default mapping sets color = after_stat(norm). geom_gradient_field2() uses default mapping sets length = after_stat(norm) (color unmapped default).","code":""},{"path":"/reference/geom_gradient_field.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"geom_gradient_field() geom_gradient_field2() understand following aesthetics (required aesthetics bold): x: x-coordinate seed point. y: y-coordinate seed point. color: geom_gradient_field, color gradient vector. geom_gradient_field2, color mapped default. length: geom_gradient_field2, computed vector norm. size, linetype, alpha: Additional aesthetics control appearance.","code":""},{"path":"/reference/geom_gradient_field.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed Variables","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"following variables computed internally StatStreamField generating gradient field scalar function: norm Euclidean norm gradient vector, calculated \\(\\sqrt{fx^2 + fy^2}\\). value used, default, mapping color scaling arrow lengths visualization. avg_spd variable may represent average speed computed gradient magnitude. default mapping geom_gradient_field, color aesthetic mapped after_stat(avg_spd).","code":""},{"path":"/reference/geom_gradient_field.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Gradient Field Layer in ggplot2 ‚Äî geom_gradient_field","text":"","code":"Si <- matrix(c(1, 0.75, 0.75, 1), nrow = 2) f <- function(u) exp(-as.numeric(u %*% solve(Si) %*% u) / 2) / (2 * pi * det(Si))  ggplot() +   geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3))   if (FALSE) { # \\dontrun{ df <- expand.grid(x = seq(-3, 3, 0.1), y = seq(-3, 3, 0.1)) |>   transform(fxy = apply(cbind(x, y), 1, f))  ggplot() +   geom_raster(aes(x, y, fill = fxy), data = df) +   geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +   coord_equal()  fxy <- function(x, y) apply(cbind(x,y), 1, f)  ggplot() +   ggdensity::geom_hdr_fun(fun = fxy, xlim = c(-3,3), ylim = c(-3,3)) +   geom_gradient_field(fun = f, xlim = c(-3,3), ylim = c(-3,3)) +   coord_equal()    library(\"ggdensity\")   fxy <- function(x, y) apply(cbind(x, y), 1, f)   fxy(1, 2)   f(1:2)    ggplot() +     geom_hdr_fun(fun = fxy, xlim = c(-3, 3), ylim = c(-3, 3)) +     geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +     coord_equal() } # }"},{"path":"/reference/geom_gradient_smooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"geom_gradient_smooth() creates ggplot2 layer visualizes gradient scalar field computed raw data. linear model fitted using supplied formula (default: z ~ x + y + (x^2) + (y^2)) raw data, numerical gradient computed using numDeriv::grad(). computed gradient field visualized using GeomStream().","code":""},{"path":"/reference/geom_gradient_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"","code":"geom_gradient_smooth(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   formula = z ~ x + y + I(x^2) + I(y^2),   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = TRUE,   type = \"vector\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = grid::unit(0.02, \"npc\"), type = \"closed\") )  stat_gradient_smooth(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = TRUE,   formula = z ~ x + y + I(x^2) + I(y^2),   xlim = NULL,   ylim = NULL,   n = 11,   max_it = 1000,   T = NULL,   L = NULL,   center = TRUE,   type = \"vector\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = grid::unit(0.02, \"npc\"), type = \"closed\") )"},{"path":"/reference/geom_gradient_smooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"mapping set aesthetic mappings created ggplot2::aes(). Required: Must include x y; vector displacements defined fx fy. data data frame containing raw vector data. stat statistical transformation use data. Defaults \"vector_smooth\". position Position adjustment, either string result position adjustment function. ... Additional arguments passed layer. na.rm Logical. FALSE (default), missing values removed warning. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . formula formula specifying linear model scalar field. Defaults z ~ x + y + (x^2) + (y^2). xlim Numeric vector length 2 specifying domain limits \\(x\\)-direction. Defaults \\(c(-1, 1)\\). ylim Numeric vector length 2 specifying domain limits \\(y\\)-direction. Defaults \\(c(-1, 1)\\). n integer vector specifying grid resolution smoothing. max_it Maximum number iterations field integration (used streamlines). T normalize = FALSE, controls time length growing streams. L normalize = TRUE, controls fixed length streams vectors. center Logical. TRUE, vector recentered original (x, y) becomes midpoint (default TRUE geom_vector() FALSE geom_vector2()). type Character. Either \"stream\" (default) \"vector\". \"stream\" computes full streamline integrating directions (center = TRUE), \"vector\" computes single vector. normalize Logical. TRUE, vector endpoints scaled unit length scaled L (default: TRUE). tail_point Logical. TRUE, draws tail point vectors/streams (default: FALSE). eval_point Logical. TRUE, marks evaluation points used fit gradients. grid user-supplied data frame pattern (e.g., \"hex\") specifying custom evaluation points. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow optional grid::arrow() specification add arrowheads vectors (default: grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\")). geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_gradient_smooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"ggplot2 layer can added ggplot object.","code":""},{"path":"/reference/geom_gradient_smooth.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"geom_gradient_smooth() supports following aesthetics (required aesthetics bold): x: x-coordinate data point. y: y-coordinate data point. z: scalar value used computing gradient. color: color used gradient vectors. Defaults depend selected type.","code":""},{"path":"/reference/geom_gradient_smooth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"Gradient Calculation: linear model fitted using provided formula raw data. scalar field defined model differentiated numerically numDeriv::grad() yield gradient vectors. Visualization: resulting gradient field visualized using GeomStream(). Since z used internally, dropped final visual output.","code":""},{"path":"/reference/geom_gradient_smooth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Gradient Smoothed Field Layer ‚Äî geom_gradient_smooth","text":"","code":"if (FALSE) { # \\dontrun{ # Define several scalar field functions:  # Example 1: f(x, y) = x^2 - y^2 f <- function(u) {   x <- u[1]   y <- u[2]   x^2 - y^2 }  # Example 2: g(x, y) = sin(x) * cos(y) g <- function(u) {   x <- u[1]   y <- u[2]   sin(x) * cos(y) }  # Example 3: h(x, y) = log(|x| + 1) + sqrt(|y|) h <- function(u) {   x <- u[1]   y <- u[2]   log(abs(x) + 1) + sqrt(abs(y)) }  # Create a grid of evaluation points grid_data <- expand.grid(   x = seq(-5, 5, length.out = 30),   y = seq(-5, 5, length.out = 30) )  # Compute the scalar field for f and plot its gradient grid_data$z <- apply(grid_data, 1, f)  ggplot(grid_data, aes(x = x, y = y, z = z)) +   geom_gradient_smooth()  # Compute and plot for g: grid_data$z <- apply(grid_data, 1, g) ggplot(grid_data, aes(x = x, y = y, z = z)) +   geom_gradient_smooth()  # Compute and plot for h: grid_data$z <- apply(grid_data, 1, h) ggplot(grid_data, aes(x = x, y = y, z = z)) +   geom_gradient_smooth() } # }"},{"path":"/reference/geom_potential.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"geom_potential() adds raster layer ggplot object, visualizing potential function derived conservative vector field. computes potential numerically specified grid displays heatmap.","code":""},{"path":"/reference/geom_potential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"","code":"geom_potential(   mapping = NULL,   data = NULL,   stat = StatPotential,   position = \"identity\",   ...,   na.rm = FALSE,   inherit.aes = TRUE,   show.legend = NA,   fun,   xlim = NULL,   ylim = NULL,   n = 51,   tol = 1e-06,   verify_conservative = FALSE )  stat_potential(   mapping = NULL,   data = NULL,   geom = GeomPotential,   position = \"identity\",   ...,   na.rm = FALSE,   inherit.aes = TRUE,   show.legend = NA,   fun,   xlim = NULL,   ylim = NULL,   n = 51,   tol = 1e-06,   verify_conservative = FALSE )"},{"path":"/reference/geom_potential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"mapping set aesthetic mappings created ggplot2::aes(). (Optional) data data displayed layer. NULL, data inherited plot. stat statistical transformation use data (default: StatPotential). position Position adjustment, either string result position adjustment function. ... arguments passed grid::layer() underlying methods. na.rm Logical. FALSE (default), missing values removed warning. inherit.aes Logical. FALSE, overrides default aesthetics rather combining . show.legend Logical. layer included legends? fun function takes numeric vector length 2 (c(x, y)) returns numeric value, defining conservative vector field. (Required) xlim Numeric vector length 2 defining domain limits x-axis. Defaults c(-1, 1). ylim Numeric vector length 2 defining domain limits y-axis. Defaults c(-1, 1). n Integer. Number grid points along axis computing potential. Defaults 21. tol Numeric. Tolerance verifying vector field conservative. Defaults 1e-6. verify_conservative Logical. TRUE, function verifies provided vector field conservative (.e., mixed partial derivatives equal within specified tolerance). Defaults FALSE. geom geometric object used render potential function. Defaults GeomPotential.","code":""},{"path":"/reference/geom_potential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"ggplot2 layer produces potential function heatmap.","code":""},{"path":"/reference/geom_potential.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"Note: potential known constant. point reference used lower left corner c(xlim[1], ylim[1]), potential assumed 0.","code":""},{"path":"/reference/geom_potential.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"geom_potential() accepts aesthetics supported GeomRaster. particular, key aesthetics include: fill: computed potential value grid cell, mapped color scale. x y: coordinates grid cell centers. (calculated) alpha: Controls transparency raster fill. Additional raster-specific aesthetics (e.g. controlled scale_fill_gradient(), scale_fill_viridis_c(), etc.) can applied modify appearance potential heatmap.","code":""},{"path":"/reference/geom_potential.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed Variables","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"following variable computed internally StatPotential potential function calculation: Potential scalar potential value computed numerically grid point. represents accumulated potential reference point (typically lower bounds xlim ylim) given point. value mapped fill aesthetic raster layer.","code":""},{"path":"/reference/geom_potential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute and Plot Potential Function from a Conservative Vector Field ‚Äî geom_potential","text":"","code":"if (FALSE) { # \\dontrun{ scalar_field <- function(u){   x <- u[1]; y <- u[2]   (x + y)^2 + 4*(x - y)^2 - 8*(.5)^2 }  gradient_field <- function(u) numDeriv::grad(scalar_field, u)  s <- seq(-1, 1, length.out = 51)  expand.grid(\"x\" = s, \"y\" = s) |>   transform(phi = apply(cbind(x, y), 1, scalar_field)) |>   ggplot(aes(x, y)) + geom_raster(aes(fill = phi))  ggplot() + geom_potential(fun = gradient_field)  ggplot() + geom_potential(fun = gradient_field, verify_conservative = TRUE) } # }"},{"path":"/reference/geom_stream.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"geom_stream() generates ggplot2 layer visualizes data continuous streams temporal variable t. stream defined required aesthetics x, y, t, optionally grouped group (mapped id). Within group, data points automatically ordered t form continuous path.","code":""},{"path":"/reference/geom_stream.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"","code":"geom_stream(   mapping = NULL,   data = NULL,   stat = StatStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   arrow.fill = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\") )  stat_stream(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   arrow.fill = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\") )"},{"path":"/reference/geom_stream.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"mapping set aesthetic mappings created ggplot2::aes(). Required: Must include x, y, t; additionally, group used differentiate streams (provided, id mapped group automatically). data data frame object, grid::layer(). stat statistical transformation use data layer; defaults StatStream. position Position adjustment, either string result position adjustment function. ... arguments passed underlying layers customization. na.rm Logical. FALSE (default), missing values removed warning. TRUE, missing values silently removed. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . arrow.fill optional parameter specifying color arrow head. Defaults NULL inherets fill/alpha aes(). lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow optional grid::arrow() specification place arrowheads streamline. geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_stream.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"ggplot2 layer can added plot produce streamline visualization.","code":""},{"path":"/reference/geom_stream.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"two variants: geom_stream(): convenient wrapper sets stat = StatStream uses ggplot2::GeomPath default. stat_stream(): Provides direct access reordering stat (.e. StatStream) advanced customization, using GeomStream drawing.","code":""},{"path":"/reference/geom_stream.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"geom_stream() stat_stream() understand following aesthetics (required aesthetics bold): x: Horizontal position. y: Vertical position. t: Temporal ordered variable used sequence data points. provided, default sequence ranging 0 1 automatically generated group (data grouping provided). group: Grouping variable multiple streams (automatically mapped id absent). color/colour: Color stream. provided, automatically mapped computed t value. linetype: Type line used draw stream. linewidth: Thickness stream line. alpha: Transparency stream.","code":""},{"path":"/reference/geom_stream.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"Data Ordering: t provided, default sequence (0 1) generated per group (entire dataset grouping specified). Points within group sorted t prior drawing stream.","code":""},{"path":"/reference/geom_stream.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed Variables","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"calculated 'stat' part layers can accessed delayed evaluation. norm variable calculated Euclidean distance derived ranges x y values. serves normalization factor vector lengths normalize parameter active. avg_spd Represents average speed, defined length stream divided time took traverse distance.","code":""},{"path":"/reference/geom_stream.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Streamline Plot Layer in ggplot2 ‚Äî geom_stream","text":"","code":"n <- 25 s <- seq(0, 1, length.out = n+1)[-(n+1)] df <- data.frame( \"t\" = s, \"x\" = cos(2*pi*s), \"y\" = sin(2*pi*s) )  ggplot(df) +   geom_stream(aes(x, y, t = t)) +   coord_equal()   ggplot(df) +   geom_stream(aes(x, y, t = t, alpha = t), size = 5) +   coord_equal() #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ‚Ñπ Please use `linewidth` instead.   ggplot(df) +   geom_path(aes(x, y, alpha = t), size = 5) +   coord_equal()    stream_1 <- data.frame(   x = c(0, 3),   y = c(0, 0),   t = 0:1 )  stream_2 <- data.frame(   x = c(1, 1),   y = c(1, 5),   t = 0:1 )  stream_3 <- data.frame(   x = c(2, 5),   y = c(2, 6),   t = 0:1 )  streams <- rbind(   cbind(stream_1, id = 1),   cbind(stream_2, id = 2),   cbind(stream_3, id = 3) )  ggplot(stream_1) +   geom_stream(aes(x = x, y = y, t = t))   # set group aes if multiple vectors ggplot(streams) +   geom_stream(aes(x = x, y = y, t = t, group = id))"},{"path":"/reference/geom_stream_field.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"geom_stream_field() creates ggplot2 layer integrates user-defined vector field function \\(f(x, y) \\(dx, dy)\\) grid seed points within specified domain. function numerically integrates field starting seeds, producing streamlines visualize flow. useful visualizing vector fields, flow patterns, trajectories, fluid dynamics gradient fields.","code":""},{"path":"/reference/geom_stream_field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"","code":"geom_stream_field(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   max_it = 1000L,   tol = sqrt(.Machine$double.eps),   T = NULL,   L = NULL,   center = TRUE,   type = \"stream\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   method = \"rk4\",   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = unit(0.02, \"npc\"), type = \"closed\") )  stat_stream_field(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   max_it = 1000,   tol = sqrt(.Machine$double.eps),   T = NULL,   L = NULL,   center = TRUE,   type = \"stream\",   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   method = \"rk4\",   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = unit(0.02, \"npc\"), type = \"closed\") )  geom_stream_field2(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   max_it = 1000,   tol = sqrt(.Machine$double.eps),   L = NULL,   center = FALSE,   type = \"stream\",   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   method = \"rk4\" )  stat_stream_field2(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   max_it = 1000,   tol = sqrt(.Machine$double.eps),   L = NULL,   center = FALSE,   type = \"stream\",   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   method = \"rk4\" )"},{"path":"/reference/geom_stream_field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"mapping set aesthetic mappings created ggplot2::aes(). (Optional) data data frame object, ggplot2::layer(). (Optional) stat statistical transformation use data (default: StatStreamField). position Position adjustment, either string result position adjustment function. ... arguments passed ggplot2::layer() underlying geometry/stat. na.rm Logical. FALSE (default), missing values removed warning. TRUE, missing values silently removed. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . fun function two variables, fun(x, y), returning two-element vector \\((dx, dy)\\) defines local flow direction point. xlim Numeric vector length 2 specifying domain limits \\(x\\)-direction. Defaults \\(c(-1, 1)\\). ylim Numeric vector length 2 specifying domain limits \\(y\\)-direction. Defaults \\(c(-1, 1)\\). n Integer two-element numeric vector specifying grid resolution (number seed points) along axis. Defaults 11, producing \\(11 \\times 11\\) grid. args list additional arguments passed fun. max_it integer(1); Maximum number integration steps per streamline (default: 1000L). tol numeric(1); tolerance used determine sink hit, among things (default: sqrt(.Machine$double.eps)). T Numeric. normalize = FALSE, streamline integrated fixed time T cropped match duration fastest streamline reaching arc length L. normalize = TRUE, integration instead stops cumulative arc length reaches L, parameter T ignored. L Numeric. Maximum arc length streamline. normalize = TRUE, integration stops cumulative arc length reaches L. normalize = FALSE, streamlines initially computed fixed time T cropped truncated duration takes fastest streamline reach arc length L. Defaults NULL (suitable default computed grid spacing). center Logical. TRUE (default), centers seed points (resulting streamlines) original (x, y) becomes midpoint. type Character. Either \"stream\" (default) \"vector\". \"stream\" computes full streamline integrating directions (center = TRUE), \"vector\" computes single vector. normalize Logical. normalize = TRUE (default), streamline integrated cumulative arc length reaches specified value L, ensuring streams uniform, normalized length based grid spacing. normalize = FALSE, integration runs fixed time (T), afterward, streamlines cropped duration takes fastest one reach length L, allowing variations arc lengths reflect differences flow speeds. tail_point Logical. TRUE, draws point tail (starting point) streamline. Defaults FALSE. eval_point Logical. TRUE, draws point evaluation point field computed. Defaults FALSE. grid data frame containing precomputed grid points seed placement. NULL (default), regular Cartesian grid generated based xlim, ylim, n. method Character. Integration method (e.g. \"rk4\" Runge-Kutta 4, \"euler\" Euler's method). Defaults \"rk4\". lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow grid::arrow() specification adding arrowheads streamlines. Defaults closed arrow 30¬∞ angle length 0.02 npc. geom geometric object used render streamlines (defaults GeomStream).","code":""},{"path":"/reference/geom_stream_field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"ggplot2 layer computes renders streamlines specified domain.","code":""},{"path":"/reference/geom_stream_field.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"geom_stream_field() (stat variant) inherit aesthetics GeomStream understand following: x: x-coordinate seed point. y: y-coordinate seed point. color: Color, typically used represent computed statistics (e.g. average speed). linetype: Type line used draw streamlines. linewidth: Thickness streamlines. alpha: Transparency streamlines.","code":""},{"path":"/reference/geom_stream_field.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"streamlines generated numerically integrating vector field defined fun(x, y). normalize = TRUE, integration stops cumulative arc length reaches L; otherwise, integration runs time T reached. T L provided incompatible combinations, one parameter ignored. computed paths rendered GeomStream.","code":""},{"path":"/reference/geom_stream_field.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed Variables","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"following variables computed internally StatStreamField integration vector field: avg_spd vector fields, computed total arc length divided integration time, providing estimate average speed. used scale vector lengths mapping length = after_stat(norm). t integration time computed point along streamline. d distance consecutive points along computed path. l cumulative arc length along streamline, calculated cumulative sum d.","code":""},{"path":"/reference/geom_stream_field.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Stream Field Layer in ggplot2 ‚Äî geom_stream_field","text":"","code":"f <- function(u) c(-u[2], u[1])  # the basic usage involves providing a fun, xlim, and ylim ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))  if (FALSE) { # \\dontrun{ # if unspecified, xlim and ylim default to c(-1,1). we use this in what # follows to focus on other parts of the code ggplot() + geom_stream_field(fun = f) ggplot() + geom_stream_field(fun = f, center = FALSE)  ggplot() + geom_stream_field(fun = f, normalize = FALSE) ggplot() + geom_stream_field(fun = f, normalize = FALSE, center = FALSE)  # run systems until specified lengths ggplot() + geom_stream_field(fun = f, normalize = TRUE, L = .8) ggplot() + geom_vector_field(fun = f, normalize = TRUE, L = .3) ggplot() + geom_vector_field(fun = f, normalize = FALSE, L = 2)  # run systems for specified times ggplot() + geom_stream_field(fun = f, normalize = FALSE, T = .1)  # tail and eval points ggplot() + geom_stream_field(fun = f, tail_point = TRUE) ggplot() + geom_stream_field(fun = f, eval_point = TRUE)  # changing the grid of evaluation ggplot() + geom_stream_field(fun = f) ggplot() + geom_stream_field(fun = f, grid = \"hex\") ggplot() + geom_stream_field(fun = f, grid = \"hex\", n = 5) ggplot() + geom_stream_field(fun = f, n = 5) ggplot() + geom_stream_field(fun = f, xlim = c(-5, 5)) + coord_equal() ggplot() + geom_stream_field(fun = f, xlim = c(-5, 5), n = c(21, 11)) + coord_equal() ggplot() + geom_stream_field(fun = f) ggplot() + geom_stream_field(fun = f, grid = grid_hex(c(-1,1), c(-1,1), .2))  # using other ggplot2 tools f <- efield_maker()  ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))  ggplot() +   geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +   scale_color_viridis_c(trans = \"log10\")  ggplot() +   geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) +   scale_color_viridis_c(trans = \"log10\") +   coord_equal()   # other vector fields f <- function(u) u ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))  f <- function(u) c(2,1) ggplot() + geom_stream_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))    # neat examples f <- function(u) {   x <- u[1]; y <- u[2]   c(y, y*(-x^2 - 2*y^2 + 1) - x) } ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2), type = \"vector\")  f <- function(u) {   x <- u[1]; y <- u[2]   c(y, x - x^3) } ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2),   grid = grid_hex(c(-2,2), c(-2,2), .35))  f <- function(u) {   x <- u[1]; y <- u[2]   c(x^2 - y^2, x^2 + y^2 - 2) } ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2),   grid = grid_hex(c(-2,2), c(-2,2), .35))  ggplot() +   geom_stream_field(fun = f, aes(alpha = after_stat(t)), xlim = c(-2,2), ylim = c(-2,2)) +   scale_alpha(range  = c(0,1))  ggplot() +   geom_stream_field(     fun = f, xlim = c(-1,1), ylim = c(-1,1),     linewidth = .75, arrow = arrow(length = unit(0.015, \"npc\"))   ) } # }"},{"path":"/reference/geom_stream_smooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"norm Computed Euclidean norm displacement, \\(\\sqrt{fx^2 + fy^2}\\), variable used normalize scale vector lengths. t integration time evaluation time computed point along smoothed field (applicable). d incremental distance consecutive computed points. l cumulative arc length along smoothed vector field, calculated cumulative sum d.","code":""},{"path":"/reference/geom_stream_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"","code":"geom_stream_smooth(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   n = 11,   xlim = NULL,   ylim = NULL,   normalize = TRUE,   center = FALSE,   type = \"vector\",   formula = cbind(fx, fy) ~ x * y,   method = \"gam\",   eval_points = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 20, length = unit(0.015, \"npc\"), type = \"closed\") )  stat_stream_smooth(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   n = 11,   xlim = NULL,   ylim = NULL,   normalize = TRUE,   center = FALSE,   type = \"vector\",   method = \"gam\",   formula = cbind(fx, fy) ~ x * y,   eval_points = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 20, length = unit(0.015, \"npc\"), type = \"closed\") )"},{"path":"/reference/geom_stream_smooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"mapping set aesthetic mappings created ggplot2::aes(). Required: Must include x y; vector displacements defined fx fy. data data frame containing raw vector data. stat statistical transformation use data. Defaults \"vector_smooth\". position Position adjustment, either string result position adjustment function. ... Additional arguments passed layer. fixed parameter color provided, color = \"blue\" used. na.rm Logical. FALSE (default), missing values removed warning. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . n integer vector specifying grid resolution smoothing. xlim Numeric vector length 2 specifying domain limits \\(x\\)-direction. Defaults \\(c(-1, 1)\\). ylim Numeric vector length 2 specifying domain limits \\(y\\)-direction. Defaults \\(c(-1, 1)\\). normalize Logical. TRUE, vector endpoints scaled unit length scaled L (default: TRUE). center Logical. TRUE, vector recentered original (x, y) becomes midpoint (default TRUE geom_vector() FALSE geom_vector2()). type Character. Either \"stream\" (default) \"vector\". \"stream\" computes full streamline integrating directions (center = TRUE), \"vector\" computes single vector. formula formula specifying multivariate linear model used smoothing. Defaults cbind(fx, fy) ~ x * y. method either \"gam\" (default) \"lm\". eval_points data frame evaluation points, NULL. provided, specifies grid smoothing model evaluated; NULL, grid generated based n. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow optional grid::arrow() specification add arrowheads vectors (default: grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\")). geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_stream_smooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"ggplot2 layer can added ggplot object display smoothed vector field.","code":""},{"path":"/reference/geom_stream_smooth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"geom_stream_smooth() creates ggplot2 layer visualizes smooth vector field based raw vector data. function fits multivariate linear model (default, using formula cbind(fx, fy) ~ x * y) predict vector displacements given location. also handles different input formats converting polar coordinates endpoint data vector displacements.","code":""},{"path":"/reference/geom_stream_smooth.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"geom_stream_smooth() supports following aesthetics (required aesthetics bold): x: x-coordinate vector's starting point. y: y-coordinate vector's starting point. fx: displacement along x-axis. fy: displacement along y-axis. color: fixed color vector. Defaults \"blue\". linewidth: thickness vector line. linetype: type vector line (e.g., solid dashed). alpha: transparency level vector. arrow: Specifies arrowheads vectors.","code":""},{"path":"/reference/geom_stream_smooth.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"Data Conversion: xend/yend missing NA, function computes . first checks vector displacements (fx fy); present, computes \\(xend = x + fx,\\quad yend = y + fy.\\) Otherwise, checks polar coordinates (angle distance) computes \\(xend = x +   distance \\times \\cos(angle \\times 180/\\pi),\\quad yend = y + distance \\times   \\sin(angle \\times 180/\\pi).\\) error thrown neither set available. Smoothing: multivariate linear model fitted using provided formula data. model used predict vector displacements specified grid point, generating smooth approximation vector field. Prediction Intervals: Two types prediction intervals can displayed: Ellipse: Depicts joint uncertainty (covariance) predicted fx fy. Wedge: Indicates range possible vector directions magnitudes.","code":""},{"path":"/reference/geom_stream_smooth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Smoothed Vector Field Layer ‚Äî geom_stream_smooth","text":"","code":"if (FALSE) { # \\dontrun{ # Define a true vector field function f <- function(u) {   x <- u[1]; y <- u[2]   c(x^2 - y^2, x^2 + y^2 - 2) }  # Alternative example function f <- function(u) c(-u[2], u[1])  # Visualize the vector field ggplot() + geom_stream_field(fun = f, xlim = c(-2, 2), ylim = c(-2, 2))  # Generate design points n <- 20 df <- data.frame(x = runif(n, -2, 2), y = runif(n, -2, 2))  # Sample function values at design points fdf <- as.data.frame(t(apply(df, 1, f))) colnames(fdf) <- c(\"fx\", \"fy\") df <- cbind(df, fdf)  # Visualize raw vector field data ggplot(df) + geom_vector(aes(x, y, fx = fx, fy = fy))  # Add smoothed layer using default model ggplot(df) +   geom_vector(aes(x, y, fx = fx, fy = fy)) +   geom_stream_smooth(formula = cbind(fx, fy) ~ x * y)  # Use a more complex polynomial model ggplot(df) +   geom_vector(aes(x, y, fx = fx, fy = fy)) +   geom_stream_smooth(formula = cbind(fx, fy) ~ poly(x, 2) * poly(y, 2), data = df)  # Fit a linear model and use it for prediction fhat <- function(u) {   model <- lm(cbind(fx, fy) ~ x * y, data = df)   predict(model, newdata = data.frame(x = u[1], y = u[2])) |> as.numeric() }  # Visualize estimated field with the raw vector field ggplot(df) +   geom_stream_field(fun = fhat, normalize = FALSE, color = \"#3366FF\") +   geom_vector(aes(x, y, fx = fx, fy = fy))  # Generate a hexagonal grid hex_lattice <- grid_hex(xlim = c(-5, 5), ylim = c(-5, 5), d = 1)  # Use the hexagonal grid in geom_stream_field ggplot(data = df) +   geom_vector(aes(x, y, fx = fx, fy = fy), color = \"black\", normalize = FALSE) +   geom_stream_smooth(eval_points = hex_lattice)  # user specified point  eval_pts <- data.frame(x = c(0, 1), y = c(2, -1))  ggplot(data = df) +   geom_vector(aes(x, y, fx = fx, fy = fy), color = \"black\", normalize = FALSE) +   geom_stream_smooth(eval_points = eval_pts) } # }"},{"path":"/reference/geom_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector Layers for ggplot2 ‚Äî geom_vector","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"Create layers drawing vectors ggplot2 plots. functions accept wide-format data required aesthetics x y plus either xend yend one alternative specifications: fx fy, angle/ angle_deg distance.","code":""},{"path":"/reference/geom_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"","code":"geom_vector(   mapping = NULL,   data = NULL,   stat = StatVector,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   center = TRUE,   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   L = NULL,   arrow = grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\") )  stat_vector(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   center = TRUE,   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   L = NULL,   arrow = grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\") )  geom_vector2(   mapping = NULL,   data = NULL,   stat = StatVector,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   center = FALSE,   tail_point = TRUE,   eval_point = FALSE,   L = NULL,   arrow = NULL )  stat_vector2(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   center = FALSE,   tail_point = TRUE,   eval_point = FALSE,   L = NULL,   arrow = NULL )"},{"path":"/reference/geom_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"mapping set aesthetic mappings created ggplot2::aes(). Required: Must include x y; addition, either xend yend one alternative specifications (fx/ fy angle/ angle_deg distance) must provided. data data frame containing vector data wide format. stat statistical transformation use data (default: StatVector). position Position adjustment, either string result position adjustment function. ... arguments passed grid::layer(). na.rm Logical. FALSE (default), missing values removed warning. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . center Logical. TRUE, vector recentered original (x, y) becomes midpoint (default TRUE geom_vector() FALSE geom_vector2()). normalize Logical. TRUE, vector endpoints scaled unit length scaled L (default: TRUE). tail_point Logical. TRUE, point drawn tail (starting point) vector (default FALSE geom_vector() TRUE geom_vector2()). eval_point Logical. TRUE, point drawn evaluation point corresponding original (untransformed) seed point centering normalization (default: FALSE). L Numeric scalar. desired length vectors data units. NULL (default), value computed automatically based plot‚Äôs x y limits. arrow optional grid::arrow() specification add arrowheads vectors (default: grid::arrow(angle = 25, length = unit(0.025, \"npc\"), type = \"closed\")). geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"ggplot2 layer can added plot.","code":""},{"path":"/reference/geom_vector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"specifying vector direction using polar coordinates, can provide either: angle: vector direction radians. angle_deg: vector direction degrees (automatically converted radians). endpoints computed translating starting point using polar coordinates along supplied distance. data converted long format (two rows per vector) via StatVector rendered GeomStream. Optionally, arrowheads can added indicate direction. two variants: geom_vector(): Uses user-supplied aesthetic mapping. geom_vector2(): Uses underlying stat (StatVector) adds default mapping length = after_stat(norm), making computed vector norm available aesthetic.","code":""},{"path":"/reference/geom_vector.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"geom_vector() geom_vector2() understand following aesthetics (required aesthetics bold): x y xend yend fx (alternative specification) fy (alternative specification) angle (vector direction radians; alternative specification) angle_deg (vector direction degrees; alternative specification, converted radians) distance (angle/angle_deg, used compute endpoints) alpha color fill group linetype size","code":""},{"path":"/reference/geom_vector.html","id":"computed-variables","dir":"Reference","previous_headings":"","what":"Computed Variables","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"calculated 'stat' part layers can accessed delayed evaluation. norm Calculated Euclidean distance starting point (x, y) computed endpoint (xend, yend). value used normalize vector length normalize parameter set TRUE.","code":""},{"path":"/reference/geom_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector Layers for ggplot2 ‚Äî geom_vector","text":"","code":"set.seed(1234) n <- 10  # Generate wind data in polar coordinates data <- data.frame(   x = rnorm(n),   y = rnorm(n),   dir = runif(n, -pi, pi), # angle in radians   spd = rchisq(n, df = 2)  # speed ) |>   transform(fx = spd * cos(dir), fy = spd * sin(dir))  # Using fx/fy to compute endpoints ggplot(data, aes(x, y)) +   geom_vector(aes(fx = fx, fy = fy))   # Using angle (in radians) and distance to compute endpoints ggplot(data, aes(x, y)) +   geom_vector(aes(angle = dir, distance = spd))   # Using angle_deg (in degrees) and distance to compute endpoints vectors3 <- data.frame(   x = c(0, 1, 2),   y = c(0, 1, 2),   angle_deg = c(0, 90, 45),   angle = c(0, pi/2, pi/4),   distance = c(3, 4, 5) ) ggplot(vectors3, aes(x, y)) +   geom_vector(aes(angle_deg = angle_deg, distance = distance))   # Basic usage with explicit start and end points: vectors1 <- data.frame(   x    = c(0, 1, 2),   y    = c(0, 1, 2),   xend = c(3, 1, 5),   yend = c(0, 5, 6) ) ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +   geom_vector()   # Using center = TRUE to recenter vectors: ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +   geom_vector(center = TRUE)   # Using normalize = TRUE to adjust vectors to unit length: ggplot(vectors3, aes(x = x, y = y, angle = angle, distance = distance)) +   geom_vector(normalize = TRUE)   # Using geom_vector2, which adds a default mapping for `length` ggplot(vectors1, aes(x = x, y = y, xend = xend, yend = yend)) +   geom_vector2()"},{"path":"/reference/geom_vector_field.html","id":null,"dir":"Reference","previous_headings":"","what":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"functions provide convenient ggplot2 layers drawing vector fields using streamlines.","code":""},{"path":"/reference/geom_vector_field.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"","code":"geom_vector_field(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   center = TRUE,   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = unit(0.02, \"npc\"), type = \"closed\") )  stat_vector_field(   mapping = NULL,   data = NULL,   stat = StatStreamField,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   center = TRUE,   normalize = TRUE,   tail_point = FALSE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = grid::arrow(angle = 30, length = unit(0.02, \"npc\"), type = \"closed\") )  geom_vector_field2(   mapping = NULL,   data = NULL,   stat = StatStreamField,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   center = FALSE,   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL )  stat_vector_field2(   mapping = NULL,   data = NULL,   geom = GeomStream,   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = TRUE,   inherit.aes = FALSE,   fun,   xlim = NULL,   ylim = NULL,   n = 11,   args = list(),   center = FALSE,   tail_point = TRUE,   eval_point = FALSE,   grid = NULL,   lineend = \"butt\",   linejoin = \"round\",   linemitre = 10,   arrow = NULL )"},{"path":"/reference/geom_vector_field.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"mapping set aesthetic mappings created ggplot2::aes(). Additional aesthetics color, size, linetype, alpha can defined. geom_vector_field, default mapping includes color = after_stat(norm), whereas geom_vector_field2 default mapping includes length = after_stat(norm). data data frame containing input data. stat statistical transformation use data layer. Defaults StatStreamField. position Position adjustment, either string result call position adjustment function. ... arguments passed grid::layer(). na.rm Logical. FALSE (default), missing values removed warning. show.legend Logical. layer included legends? inherit.aes Logical. FALSE, overrides default aesthetics rather combining . fun function defines vector field. take numeric vector length 2 (representing \\((x, y)\\)) return numeric vector length 2 (representing \\((dx, dy)\\)). (Required) xlim Numeric vector length two. Specifies limits x-axis domain. Defaults c(-1, 1). ylim Numeric vector length two. Specifies limits y-axis domain. Defaults c(-1, 1). n Integer. Grid resolution specifying number seed points along axis. Higher values produce denser vector field. Defaults 11. args List additional arguments passed function defined fun. center Logical. TRUE, centers seed points vectors original (x, y) becomes midpoint. Defaults differ variants. normalize Logical. TRUE, stream lengths normalized based grid spacing. FALSE, default arc length used. (Default TRUE; TRUE, converted internally \"vector\".) tail_point Logical. TRUE, point drawn tail streamline. eval_point Logical. TRUE, point drawn evaluation point, corresponding original (untransformed) seed point centering normalization applied. grid data frame containing precomputed grid points seed placement. NULL (default), regular Cartesian grid generated based xlim, ylim, n. lineend Line end style (round, butt, square). linejoin Line join style (round, mitre, bevel). linemitre Line mitre limit (number greater 1). arrow grid::arrow() specification add arrowheads streamlines. geom_vector_field, default closed arrow 30¬∞ angle length 0.02 npc; geom_vector_field2 default NULL. geom geometric object used render streamline (used stat_stream(); defaults GeomStream).","code":""},{"path":"/reference/geom_vector_field.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"ggplot2 layer computes plots vector field using streamlines. norm Calculated Euclidean distance starting point (x, y) computed endpoint. Used normalize vector.","code":""},{"path":"/reference/geom_vector_field.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"user-defined function (fun) specifies behavior vector field taking numeric vector length 2 (representing \\((x, y)\\)) returning numeric vector length 2 (representing \\((dx, dy)\\)). underlying StatStreamField computes streamlines based vector field function, GeomStream renders . Two variants provided: geom_vector_field() uses default mapping sets color = after_stat(norm). geom_vector_field2() uses default mapping sets length = after_stat(norm) (color unmapped default).","code":""},{"path":"/reference/geom_vector_field.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"geom_vector_field() geom_vector_field2() understand following aesthetics (required aesthetics bold): x: x-coordinate vector's starting point. y: y-coordinate vector's starting point. fx: horizontal component vector displacement. fy: vertical component vector displacement. color: color vector lines (default mapping geom_vector_field). length: computed vector norm (default mapping geom_vector_field2). linetype: type vector line (e.g., solid, dashed). linewidth: thickness vector line. alpha: transparency vector.","code":""},{"path":[]},{"path":"/reference/geom_vector_field.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vector Field Layers for ggplot2 ‚Äî geom_vector_field","text":"","code":"f <- function(u) c(-u[2], u[1]) ggplot() + geom_vector_field(fun = f, xlim = c(-1,1), ylim = c(-1,1))  if (FALSE) { # \\dontrun{ # xlim and ylim default to (-1,1), so for ease of illustration we remove them  ggplot() + geom_vector_field(fun = f) ggplot() + geom_vector_field(fun = f, grid = \"hex\")  ggplot() + geom_vector_field2(fun = f) ggplot() + geom_vector_field2(fun = f, grid = \"hex\")  f <- efield_maker() ggplot() + geom_vector_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) ggplot() + geom_vector_field2(fun = f, xlim = c(-2,2), ylim = c(-2,2)) } # }"},{"path":[]},{"path":"/reference/geom_vector_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"","code":"geom_vector_smooth(   mapping = NULL,   data = NULL,   stat = \"vector_smooth\",   position = \"identity\",   ...,   na.rm = FALSE,   show.legend = NA,   inherit.aes = TRUE,   n = c(11, 11),   method = \"gam\",   se = TRUE,   se.circle = FALSE,   pi_type = \"ellipse\",   conf_level = c(0.95, NA),   formula = cbind(fx, fy) ~ x * y,   eval_points = NULL,   arrow = grid::arrow(angle = 20, length = unit(0.015, \"npc\"), type = \"closed\") )"},{"path":"/reference/geom_vector_smooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"mapping set aesthetic mappings created ggplot2::aes(). Required: Must include x y; vector displacements defined fx fy. data data frame containing raw vector data. stat statistical transformation use data (default: \"vector_smooth\"). position Position adjustment, either string result position adjustment function. ... arguments passed ggplot2::layer() underlying geometry/stat. n integer vector specifying number grid points along axis smoothing. method Character. Specifies smoothing method. Supported options include \"lm\", \"kriging\", \"gam\". \"lm\" method fits multivariate linear model, \"kriging\" uses cokriging approach via gstat package, \"gam\" fits separate generalized additive models fx fy (predictions assumed independent, .e., zero covariance). se Logical. TRUE, prediction (confidence) intervals computed plotted. se.circle Logical. Defaults FALSE. TRUE, circles drawn around origin vector. default, circle‚Äôs radius computed magnitude predicted vector. pi_type Character. Determines display style prediction intervals: \"wedge\" (default): Angular wedges drawn. \"ellipse\": Ellipses used represent covariance predictions. pi_type set \"ellipse\" eval_points NULL, revert \"wedge\". conf_level Numeric. Specifies confidence level prediction intervals. Default 0.95. formula formula specifying multivariate linear model used smoothing. default cbind(fx, fy) ~ x * y. eval_points data frame evaluation points. provided, specify grid smoothing model evaluated. NULL, grid generated based n. arrow grid::arrow() specification arrowheads smoothed vectors.","code":""},{"path":"/reference/geom_vector_smooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"ggplot2 layer can added plot create smooth vector field visualization.","code":""},{"path":"/reference/geom_vector_smooth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"geom_vector_smooth() creates ggplot2 layer visualizes smooth vector field. takes raw vector data applies smoothing (via multivariate linear model) estimate underlying vector field. functionality analogous geom_smooth() ggplot2 tailored vector data rather scalar responses.","code":""},{"path":"/reference/geom_vector_smooth.html","id":"aesthetics","dir":"Reference","previous_headings":"","what":"Aesthetics","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"geom_vector_smooth() supports following aesthetics (required aesthetics bold): x: x-coordinate vector's starting point. y: y-coordinate vector's starting point. fx: horizontal component vector displacement. fy: vertical component vector displacement. color: color vector lines. linewidth: thickness vector lines. linetype: type vector lines (e.g., solid, dashed). alpha: transparency level vectors. arrow: aesthetic can used modify arrowhead properties.","code":""},{"path":"/reference/geom_vector_smooth.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"Multivariate Linear Model: \"lm\" method fits multivariate linear model predict vector displacements (fx fy) based coordinates x y, including interaction terms (x * y). model smooths raw vector data provide estimate underlying vector field. Prediction Intervals: se = TRUE, prediction intervals computed smoothed vectors. Two types intervals supported: Ellipse: Ellipses represent joint uncertainty (covariance) predicted fx fy. Wedge: Wedges (angular sectors) indicate range possible vector directions magnitudes. type interval displayed controlled pi_type, confidence level set via conf_level.","code":""},{"path":"/reference/geom_vector_smooth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Smooth Vector Plot Layer ‚Äî geom_vector_smooth","text":"","code":"# Function to generate vectors generate_vectors <- function(v) {   x <- v[1]   y <- v[2]   c(     sin(x) + sin(y) + rnorm(1, 5, 1),     sin(x) - sin(y) - rnorm(1, 5, 1)   ) }  # Set seed for reproducibility set.seed(123)  # Create sample points and compute vectors sample_points <- data.frame(   x = runif(30, 0, 10),   y = runif(30, 0, 10) )  result <- t(apply(sample_points, 1, generate_vectors))  sample_points$xend <- result[, 1] sample_points$yend <- result[, 2] sample_points$fx <- sample_points$xend - sample_points$x sample_points$fy <- sample_points$yend - sample_points$y sample_points$distance <- sqrt(sample_points$fx^2 + sample_points$fy^2) sample_points$angle <- atan2(sample_points$fy, sample_points$fx)  # Define evaluation points eval_points <- data.frame(   x = c(0, 7.5),   y = c(10, 5) )  # Example 1: ggplot(sample_points, aes(x = x, y = y)) +   geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +   geom_vector_smooth(aes(fx = fx, fy = fy), n = 5) +   ggtitle(\"Smoothed Vector Field\") #> Warning: ! eval_points is `NULL`; changing pi_type from \"ellipse\" to \"wedge\".   # Example 2: Ellipse with eval_points ggplot(sample_points, aes(x = x, y = y)) +   geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +   geom_vector_smooth(aes(fx = fx, fy = fy), eval_points = eval_points, conf_level = c(0.9)) +   ggtitle(\"Smoothed Vector Field with Ellipse Intervals\")   # Example 3: Wedge with eval_points ggplot(sample_points, aes(x = x, y = y)) +   geom_vector(aes(fx = fx, fy = fy, color = NULL), center = FALSE, alpha = 0.2) +   geom_vector_smooth(aes(fx = fx, fy = fy), eval_points = eval_points, pi_type = \"ellipse\") +   ggtitle(\"Smoothed Vector Field with Wedge Intervals\")"},{"path":"/reference/ggvfields.html","id":null,"dir":"Reference","previous_headings":"","what":"ggvfields: Vector Field Visualizations with ggplot2 ‚Äî ggvfields","title":"ggvfields: Vector Field Visualizations with ggplot2 ‚Äî ggvfields","text":"ggplot2 extension visualizing vector fields two-dimensional space. Provides functions create vector field layers using user-defined vector field functions.","code":""},{"path":[]},{"path":"/reference/grid_hex.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Hexagonal Lattice ‚Äî grid_hex","title":"Generate a Hexagonal Lattice ‚Äî grid_hex","text":"function generates hexagonal lattice points within given x y limits, using specified hexagon diameter. diameter 2 times distance adjacent x (y) values, see examples.","code":""},{"path":"/reference/grid_hex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Hexagonal Lattice ‚Äî grid_hex","text":"","code":"grid_hex(xlim, ylim, d)"},{"path":"/reference/grid_hex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Hexagonal Lattice ‚Äî grid_hex","text":"xlim numeric vector length 2 specifying x-axis limits. ylim numeric vector length 2 specifying y-axis limits. d numeric value specifying hexagon diameter.","code":""},{"path":"/reference/grid_hex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Hexagonal Lattice ‚Äî grid_hex","text":"data frame two columns, x y, containing coordinates hexagonal grid points.","code":""},{"path":"/reference/grid_hex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Hexagonal Lattice ‚Äî grid_hex","text":"","code":"xlim <- c(-1, 1) ylim <- c(-1, 0)  grid <- grid_hex(xlim, ylim, .25)  head( grid ) #>       x          y #> 1 -1.00 -0.8660254 #> 2 -0.75 -0.8660254 #> 3 -0.50 -0.8660254 #> 4 -0.25 -0.8660254 #> 5  0.00 -0.8660254 #> 6  0.25 -0.8660254 str( grid ) #> 'data.frame':\t43 obs. of  2 variables: #>  $ x: num  -1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1 -0.875 ... #>  $ y: num  -0.866 -0.866 -0.866 -0.866 -0.866 ... plot( grid, asp = 1 )   diff(sort(unique(grid$x))) #>  [1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125 #> [13] 0.125 0.125 0.125 0.125"},{"path":"/reference/scale_length_continuous.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Continuous Scale for Vector Length ‚Äî scale_length_continuous","title":"Create a Continuous Scale for Vector Length ‚Äî scale_length_continuous","text":"scale_length_continuous() provides continuous scale controlling length aesthetic ggplot. particularly useful working vector plots vector lengths mapped continuous scale.","code":""},{"path":"/reference/scale_length_continuous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Continuous Scale for Vector Length ‚Äî scale_length_continuous","text":"","code":"scale_length_continuous(max_range = 0.5, ...)"},{"path":"/reference/scale_length_continuous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Continuous Scale for Vector Length ‚Äî scale_length_continuous","text":"max_range maximum value input rescaled. Numeric scalar specifying upper bound output range. 0 1. ... arguments passed continuous_scale().","code":""},{"path":"/reference/scale_length_continuous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Continuous Scale for Vector Length ‚Äî scale_length_continuous","text":"max_range less equal 0.5 (default), continuous scale object (typically class \"ScaleContinuous\") mapping length aesthetic returned. max_range greater 0.5, list returned two components: continuous scale object, theme modification (theme object) adjusts legend key width based value max_range.","code":""},{"path":"/news/index.html","id":"ggvfields-100","dir":"Changelog","previous_headings":"","what":"ggvfields 1.0.0","title":"ggvfields 1.0.0","text":"CRAN release: 2025-03-15 Initial CRAN submission.","code":""}]
