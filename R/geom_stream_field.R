#' Create a Stream Field Layer in ggplot2
#'
#' [geom_stream_field()] creates a ggplot2 layer that integrates a user-defined
#' vector field function \eqn{f(x, y) \to (dx, dy)} over a grid of seed points
#' within a specified domain \eqn{(x, y)}, producing streamlines that visualize
#' the flow of the vector field. This is useful for visualizing vector fields,
#' flow patterns, or trajectories in a variety of contexts such as fluid flows
#' or gradient fields.
#'
#' @inheritParams ggplot2::geom_path
#'
#' @param fun A function of two variables, `fun(x, y)`, returning a two-element
#'   vector \eqn{(dx, dy)}. This defines the local "flow" direction at any point
#'   in the domain.
#' @param xlim,ylim Numeric vectors of length two specifying the domain limits
#'   in the \eqn{x}- and \eqn{y}-directions, respectively. Defaults to
#'   \eqn{c(-1, 1)} for both.
#' @param n Integer. Grid resolution (the number of seed points along each
#'   axis). Defaults to 11, resulting in an \eqn{n \times n} grid of seed
#'   points.
#' @param max_it Integer. Maximum number of integration steps per streamline.
#'   This controls how far each streamline can propagate. Defaults to 1000.
#' @param dt Numeric. Time-step size for integration. Smaller values produce
#'   more precise streamlines but increase computation time. Default is
#'   `0.0025`.
#' @param L Numeric. Maximum arc length for each streamline. A streamline stops
#'   once its length exceeds this value. If `NULL`, a suitable default is
#'   derived from the grid spacing. Default is `NULL`.
#' @param center Logical. If `TRUE`, centers the seed points or the resulting
#'   streamlines so that the original (x, y) becomes the midpoint. Default is
#'   `TRUE`.
#' @param normalize Logical. If `TRUE`, stream lengths are normalized based on
#'   grid spacing. If `FALSE`, a default arc length is used. Default is `TRUE`.
#' @param method Character. Integration method, e.g., `"rk4"` for Runge-Kutta 4
#'   or `"euler"` for Euler's method. Defaults to `"rk4"`.
#' @param arrow A [grid::arrow()] specification for adding arrowheads to each
#'   streamline. By default, a closed arrow with a 30Â° angle and a length of
#'   `0.02` npc is used.
#' @param tail_point Logical. If `TRUE`, a point is drawn at the tail (i.e. the
#'   starting point) of each streamline. This can help to indicate the origin of
#'   the computed path. Default is `FALSE`.
#' @param geom The geometric object used to draw the streamline. Defaults to
#'   [GeomStream].
#' @param ... Other arguments passed to [ggplot2::layer()] and the underlying
#'   geometry/stat.
#'
#' @return A ggplot2 layer that computes the streamlines over the specified
#'   domain and draws them, optionally with arrowheads and with points at the
#'   tail and/or evaluation positions.
#'
#' @details The streamlines are generated by numerically integrating the vector
#'   field defined by `fun(x, y)`. The computed streamlines are then passed to
#'   [GeomStream] for rendering. When `tail_point = TRUE`, a point is drawn at
#'   the start of each streamline. When `eval_point = TRUE`, a point is drawn at
#'   the original (untransformed) seed point, allowing you to see the location
#'   before centering or normalization is applied.
#'
#' @section See Also:
#' - [StatStreamField] for the underlying statistical transformation.
#' - [GeomStream] for the geometry that renders the resulting paths.
#' - [ggplot2::geom_path] as the base geometry on which [GeomStream] is built.
#'
#' @examples
#'
#' f <- efield_maker()
#' ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
#' ggplot() + geom_stream_field(fun = f, xlim = c(-2,2), ylim = c(-2,2)) + coord_equal()
#' ggplot() + geom_vector_field(fun = f, xlim = c(-2,2), ylim = c(-2,2))
#'
#' # Define a simple rotational vector field function
#' rotational_field <- function(u) {
#'   x <- u[1]
#'   y <- u[2]
#'   c(-y, x)
#' }
#'
#' # Create a stream field layer
#' ggplot() + geom_stream_field(fun = rotational_field)
#' ggplot() + geom_vector_field(fun = rotational_field)
#'
#' # Create a stream field layer with tail points
#' ggplot() +
#'   geom_stream_field(fun = rotational_field, tail_point = TRUE)
#'
#' # Create a stream field with centered streams
#' ggplot() +
#'   geom_stream_field(fun = rotational_field, center = TRUE)
#'
#' @name geom_stream_field
#' @aliases stat_stream_field StatStreamField
NULL




#' @rdname geom_stream_field
#' @export
geom_stream_field <- function(
    mapping = NULL,
    data = NULL,
    stat = StatStreamField,
    position = "identity",
    ...,
    na.rm = FALSE,
    show.legend = NA,
    inherit.aes = FALSE,
    # inherit.aes = TRUE,
    fun,
    xlim = NULL,
    ylim = NULL,
    n = 11,
    max_it = 1000,
    dt = .0025,
    L = NULL,
    center = TRUE,
    normalize = TRUE,
    tail_point = FALSE,
    method = "rk4",
    arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
) {

  # Define default mapping for geom_vector_field
  default_mapping <- aes(color = after_stat(avg_spd))

  # Merge user-provided mapping with default mapping
  # User mapping takes precedence
  if (!is.null(mapping)) {
    if (!"color" %in% names(mapping)) mapping <- modifyList(default_mapping, mapping)
  } else {
    mapping <- default_mapping
  }

  if (is.null(data)) data <- ensure_nonempty_data(data)
  n <- ensure_length_two(n)

  if(normalize) normalize <- "stream"

  layer(
    stat = stat,
    geom = GeomStream,
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      fun = fun,
      xlim = xlim,
      ylim = ylim,
      n = n,
      method = method,
      na.rm = na.rm,
      max_it = max_it,
      dt = dt,
      L = L,
      center = center,
      normalize = normalize,
      tail_point = tail_point,
      arrow = arrow,
      ...
    )
  )
}


#' @rdname geom_stream_field
#' @export
stat_stream_field <- function(
    mapping = NULL,
    data = NULL,
    geom = GeomStream,
    position = "identity",
    ...,
    na.rm = FALSE,
    show.legend = NA,
    inherit.aes = TRUE,
    fun,
    xlim = NULL,
    ylim = NULL,
    n = 11,
    max_it = 1000,
    dt = .0025,
    L = NULL,
    center = TRUE,
    normalize = TRUE,
    tail_point = FALSE,
    method = "rk4",
    arrow = grid::arrow(angle = 30, length = unit(0.02, "npc"), type = "closed")
) {

  # Define default mapping for geom_vector_field
  default_mapping <- aes( color = after_stat(avg_spd) )

  # Merge user-provided mapping with default mapping
  # User mapping takes precedence
  if (!is.null(mapping)) {
    if (!"color" %in% names(mapping)) {
      mapping <- modifyList(default_mapping, mapping)
    }
  } else {
    mapping <- default_mapping
  }

  if (is.null(data)) data <- ensure_nonempty_data(data)
  n <- ensure_length_two(n)
  if(normalize) normalize <- "stream"

  layer(
    stat = StatStreamField,
    geom = geom,
    data = data,
    mapping = mapping,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      fun = fun,
      xlim = xlim,
      ylim = ylim,
      n = n,
      method = method,
      na.rm = na.rm,
      max_it = max_it,
      dt = dt,
      L = L,
      center = center,
      normalize = normalize,
      tail_point = tail_point,
      arrow = arrow,
      ...
    )
  )
}


#' @rdname geom_stream_field
#' @format NULL
#' @usage NULL
#' @export
StatStreamField <- ggproto(
  "StatStreamField",
  Stat,
  default_aes = aes(group = after_stat(id)),

  compute_group = function(data, scales, fun, xlim, ylim, n, method, max_it = 1000, dt, L = NULL, center, normalize, ...) {

    xlim <- xlim %||% scales$x$range$range
    if (is.null(xlim)) {
      cli::cli_warn("No xlim provided or inherited; defaulting to c(-1, 1).")
      xlim <- c(-1, 1)
    }

    ylim <- ylim %||% scales$y$range$range
    if (is.null(ylim)) {
      cli::cli_warn("No ylim provided or inherited; defaulting to c(-1, 1).")
      ylim <- c(-1, 1)
    }

    # make grid of points on which to compute streams
    grid <- cbind(
      "x" = rep(seq(xlim[1], xlim[2], length.out = n[1]), times = n[2]),
      "y" = rep(seq(ylim[1], ylim[2], length.out = n[2]), each = n[1])
    )

    ## Get dt and L defaulted
    dt <- rep(dt, nrow(grid))
    L <- min(diff(xlim), diff(ylim))
    # L <- sqrt(diff(xlim)^2 + diff(ylim)^2)


    if(normalize == "stream") L <- L / (max(n) - 1) * 0.45

    if(normalize == "vector") {
      L <- L / (max(n) - 1) * 0.8

      # calculate dt for each grid point
      norms <- apply(grid, 1, function(v) sqrt(sum(fun(v) ^ 2)))
      dt <- L / norms # normalizes for euler: u[i,] <- u[i-1,] + f(u[i-1,])*dt = u[i,] <- u[i-1,] + f(u[i-1,]) * (L/|f(u[i-1,])|)

      # replace infinite dt values with 0
      dt[is.infinite(dt)] <- 0

    }

    # initialize the data frame
    df <- data.frame()

    for (i in 1:nrow(grid)) {

      # compute the stream for the current grid point using ode_stepper()
      stream <- transform(
        ode_stepper(grid[i, ], fun, dt[i], 0, L, max_it, method, center),
        "id" = i
      )

      # add the original x and y coordinates to this stream's data
      stream$x0 <- grid[i, "x"]
      stream$y0 <- grid[i, "y"]

      # bind the current stream's data to the overall data frame
      df <- rbind(df, stream)

    }

  # compute divergence and curl by group (each group is identified by id)
  df <- do.call(rbind, lapply(split(df, df$id), function(subdf) {

    # calculate the gradient of the vector field at each point.
    grad <- t(apply(subdf[, c("x", "y")], 1, function(v) numDeriv::grad(fun, v)))
    grad_u <- grad[, 1]
    grad_v <- grad[, 2]

    # compute divergence and curl.
    subdf$divergence <- grad_u + grad_v
    subdf$curl <- grad_v - grad_u

    subdf
  }))

  df
    # to check if df contains the right information, try this:
    # ggplot(df) +
    #   geom_path(
    #     aes(x, y, group = paste(x0, y0), color = avg_spd),
    #     arrow = arrow(length = unit(.02, "npc"))
    #   )

  }


)







ode_stepper <- function(u0, fun, dt = .005, t0 = 0, L = 1, max_it = 5000, method = "lsoda", center = FALSE) {

  if ( center ) {

    # define a few helpers
    neg_fun <- function(u) -fun(u)
    flip <- function(df) if (nrow(df) == 0L) df else df[nrow(df):1,]
    # the nrow(df) == 0 part is if the original eval point fails, vec field is not defined at that point
    # if you df[nrow(df):1,] on a 0-row df, you get back a row of NAs

    # solve in both directions
    df_negative <- ode_stepper(u0, neg_fun, dt = dt/2, t0, L = L, max_it, method, center = FALSE)
    df_negative$t <- -df_negative$t
    df_positive <- ode_stepper(u0,     fun, dt = dt/2, t0, L = L, max_it, method, center = FALSE)

    # combine the datasets
    df <- rbind( flip(df_negative[-1,]), df_positive )

    # shift lengths, recompute distances, arc length, avg speed
    n_neg <- nrow(df_negative) - 1
    n_pos <- nrow(df_positive)
    n <- nrow(df)
    df$d <- if (n == 1) NA_real_ else c(NA_real_, df$d[1:n_neg], df_positive$d[-1])
    df$l <- c(0, cumsum(df$d[-1]))
    df$avg_spd <- df$l[n] / (df$t[n] - df$t[1])

    # return
    return(df)

  }

  # wrap fun for deSolve::ode()
  df <- data.frame()
  fun_wrapper <- function(t, u, parms) {
    norm <- function(x) sqrt(sum(x^2))
    fu <- fun(u[1:2])
    # df <<- rbind( df, c(t, u[1:2], fu) |> t() |> matrix_to_df_with_names(c("t","x","y","fx","fy")) )
    df <<- rbind( df, c(t, u[1:2]) |> t() |> matrix_to_df_with_names(c("t","x","y")) )
    list( c( fu, "l" = norm(fu) ) )
  }

  rootfun <- function(t, u, parms) u[3] - parms$L

  # solve up to length L; soln is not actually used after since evals are captured
  soln <- deSolve::ode(
    func = fun_wrapper,
    y = c(u0, "l" = 0), # 0 = initial arc length
    parms = list("L" = L),
    # times = seq(0, 1, by = dt),
    times = c(0, 1e6),
    rootfun = rootfun,
    maxsteps = max_it
  )

  # deSolve::ode() only provides solutions at the times requested (0 up until
  # stop, not 1e6) but it has to evaluate the function bunches of times.
  # the wrapper above tracks these

  # compute d and l stats
  n <- nrow(df)
  df$d <- c(NA_real_, apply( df[2:n,c("x","y")] - df[1:(n-1),c("x","y")], 1, norm ))
  df$l <- c(0, cumsum(df$d[-1]))

  # crop back
  df <- df |> crop_stream_length(L)
  n <- nrow(df)
  df$avg_spd <- df$l[n] / df$t[n]
  df$norm <- norm(fun(u0))

  # return
  df

  # convert to nice data frame and return
  # n <- nrow(soln)
  # soln <- as.data.frame(soln)
  # names(soln) <- c("t", "x", "y", "l")
  #
  # with(
  #   soln,
  #   data.frame(
  #     "t" = t,
  #     "x" = x,
  #     "y" = y,
  #     "d" = c(NA_real_, diff(l)),
  #     "l" = l,
  #     "avg_spd" = l[n] / t[n],
  #     "norm" = norm(fun(u0))
  #   )
  # )

}
# f <- function(u) c(-u[2], u[1])
# ode_stepper( c(1,0), f, L = pi) |> str()
# ode_stepper( c(1,0), f, L = pi) |> tail()
# ode_stepper( c(1,0), f, L = pi) |>
#   ggplot(aes(x, y)) +
#     geom_path(aes(color = t))
#
# ode_stepper(  c(-1,1), efield_maker(), L = 2 ) |> stream_length()
# ode_stepper( c(-.2,1), efield_maker(), L = 2 ) |> stream_length()
# ode_stepper( c(-.3,1), efield_maker(), L = 2 ) |> stream_length()
#
# ode_stepper( c(-1,1), efield_maker() ) |>
#   ggplot(aes(x, y)) +
#     geom_path(aes(color = t))
#
# ode_stepper( c(-1,1), efield_maker() ) |>
#   ggplot(aes(x, y)) +
#   geom_path(aes(color = l))
#
# ode_stepper( c(-1,1), efield_maker(), L = 3 ) |>
#   ggplot(aes(x, y)) +
#   geom_path(aes(color = l))





crop_stream_length <- function(data, L) {
  # data is assumed to have columns t, x, y, d, l
  # data is assumed to be ordered by t, but if you need to ensure this you
  # can uncomment the below
  # data <- data[order(data$t),]

  # determine number of points in the path
  n <- nrow(data)

  # return data if length >= arc length of data
  # NOTE: this will need to change in the future, presumably to extent last seg
  if (L >= data$l[n]) return( data )

  # find index of first point overshooting desired length
  i <- min( which( data$l > L ) )

  # discard all the points past the first crossing
  data <- data[1:i,]

  # essentially we want data[1:(i-1),] plus another point on the line segment
  # between data[i-1,] and data[i,]. the length of that line should be enough
  # to get the total polyline length to L
  almost_L <- data$l[i-1]
  length_needed <- L - almost_L
  v <- data[i,c("x","y")] - data[i-1,c("x","y")]
  nv <- norm(v)
  m <- length_needed/nv
  data[i,c("x","y")] <- data[i-1,c("x","y")] + m * v

  # now to update t, d, and l
  data[i,"d"] <- length_needed
  data[i,"l"] <- L
  data[i,"t"] <- with(data, t[i-1] + m*(t[i]-t[i-1]))

  # return data
  data

}
# N <- 20 # set this to 2 to a single vector
# s <- seq(0, 1, length.out = N+1)[-(N+1)]
# df <- data.frame(
#   "t" = s,
#   "x" = cos(2*pi*s),
#   "y" = sin(2*pi*s)
# )
# seg_lengths <- apply(df[2:N,c("x","y")] - df[1:(N-1),c("x","y")], 1, norm)
# df$d <- c(0, seg_lengths)
# df$l <- cumsum(df$d) # note that last is ~ 2*pi, which is good
#
# df |>
#   ggplot(aes(x,y)) +
#     geom_path(aes(color = l)) +
#     coord_equal(xlim = c(-1,1), ylim = c(-1,1))
#
# df |>
#   crop_stream_length(pi) |>
#   ggplot(aes(x,y)) +
#     geom_path(aes(color = l)) +
#     coord_equal(xlim = c(-1,1), ylim = c(-1,1))




stream_length <- function(data) {

  # data is assumed to have columns t, x, y
  # t is assumed in order
  # data <- data[order(data$t),]

  # discard any columns other than x and y
  data <- data[,c("x","y")]

  # find length of path
  n <- nrow(data)
  apply(data[2:n,] - data[1:(n-1),], 1, norm) |> sum()

}
# df |> stream_length() # should match last l; does
# df |> crop_stream_length(pi) |> stream_length() # should match pi and new last l; does




stream_center <- function(data) {
  L <- stream_length(data)
  data <- crop_stream_length(data, L/2)
  data[nrow(data),]
}
# df |> stream_length()
# df |> stream_center()
# df |>
#   ggplot(aes(x, y)) +
#     geom_path() +
#     geom_point(data = stream_center(df), color = "firebrick")




# parameterization <- function(data) {
#   fx <- with(data, approxfun(t,x))
#   fy <- with(data, approxfun(t,y))
#   function(t) {
#     n <- length(t)
#     df <- cbind("x" = fx(t), "y" = fy(t)) |> matrix_to_df_with_names()
#     df$d <- c(0, apply(df[2:n,] - df[1:(n-1),], 1, norm))
#     df$l <- cumsum(df$d)
#     df$t <- t
#     df[,c("t","x","y","d","l")]
#   }
# }

# random_ts <- runif(50, min = min(df$t), max = max(df$t))
# parameterization(df)( random_ts )




# sample_stream <- function(n, data) {
#   random_ts <- runif(n, min = min(data$t), max = max(data$t))
#   parameterization(df)( random_ts )
# }
# df |>
#   ggplot(aes(x, y)) +
#     geom_path() +
#     geom_point(data = stream_center(df), color = "firebrick") +
#     geom_point(data = sample_stream(20, df), color = "steelblue") +
#     coord_equal()




# center_on_point <- function(data, point = c(0,0)) {
#
#   # compute center
#   center <- as.numeric( stream_center(data)[,c("x","y")] )
#
#   # translate each point in path by center
#   # for (i in 1:nrow(data)) data[i,c("x","y")] <- data[i,c("x","y")] - center + point
#   mat <- as.matrix( data[,c("x","y")] )
#   data[,c("x","y")] <- t( t(mat) - center + point )
#
#   # return
#   data
#
# }
# df
# df |> center_on_point()
# df |>
#   ggplot(aes(x, y)) +
#     geom_path() +
#     geom_point(data = stream_center(df), color = "firebrick") +
#     geom_path(data = center_on_point(df), color = "steelblue") +
#     coord_equal()


