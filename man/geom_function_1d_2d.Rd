% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom_function_1d_2d.R
\docType{data}
\name{geom_function_1d_2d}
\alias{geom_function_1d_2d}
\alias{stat_function_1d_2d}
\alias{Stat1d_2d}
\title{1D-to-2D Function Stream Plot for ggplot2}
\arguments{
\item{mapping}{A set of aesthetic mappings created by \code{\link[ggplot2:aes]{ggplot2::aes()}}.
Additional aesthetics such as \code{color}, \code{size}, \code{linetype}, and \code{alpha} can
be defined. The default mapping sets \code{color = after_stat(t)}.}

\item{data}{A data frame containing the input data. In many cases, no data
needs to be supplied.}

\item{geom}{The geometric object used to draw the streamline. Defaults to
\link[ggplot2:ggplot2-ggproto]{ggplot2::GeomPath} in \code{geom_stream()}, or \link{GeomStream} in \code{stat_stream()}.}

\item{position}{Position adjustment, either as a string or the result of a
call to a position adjustment function.}

\item{...}{Other arguments passed on to \code{\link[ggplot2:layer]{ggplot2::layer()}}.}

\item{na.rm}{Logical. If \code{FALSE} (the default), missing values are removed
with a warning.}

\item{show.legend}{Logical. Should this layer be included in the legends?}

\item{inherit.aes}{Logical. If \code{FALSE}, overrides the default aesthetics
rather than combining with them.}

\item{fun}{A function that defines the mapping from a scalar input (typically
time) to a two-dimensional coordinate. It should take a numeric scalar and
return a numeric vector of length 2 representing \eqn{(x, y)}.
\strong{(Required)}}

\item{t0}{Numeric. The starting value of the time sequence. Defaults to \code{0}.}

\item{T}{Numeric. The ending value of the time sequence. Defaults to \code{10}.}

\item{dt}{Numeric. The time increment for evaluating \code{fun}. Defaults to
\code{0.01}.}

\item{args}{List of additional arguments passed on to the function defined by
\code{fun}.}

\item{tail_point}{Logical. If \code{TRUE}, a point is drawn at the tail (starting
position) of the stream.}

\item{arrow}{A \code{\link[grid:arrow]{grid::arrow()}} specification to add arrowheads to the stream.
The default is a closed arrow with a 30Â° angle and a length of \code{0.02} npc.}

\item{stat}{The statistical transformation to use on the data for this layer.
Defaults to \link{Stat1d_2d}.}
}
\value{
A ggplot2 layer that computes and plots a stream by evaluating a
one-dimensional function over a time sequence.
}
\description{
These functions provide convenient ggplot2 layers for drawing streams
generated by mapping a one-dimensional input (typically time) to
two-dimensional coordinates. A user-defined function (\code{fun}) specifies the
mapping by taking a numeric scalar (e.g. time) and returning a numeric vector
of length 2 (representing \eqn{(x, y)}). The underlying \link{Stat1d_2d} evaluates
\code{fun} over a time sequence (from \code{t0} to \code{T} in increments of \code{dt}), and
\link{GeomStream} renders the resulting path.
}
\details{
In many cases these layers are useful for visualizing dynamic systems or
flows where a one-dimensional parameter (often time) drives movement in
two-dimensional space.
}
\examples{
f <- function(t) {
  c(sin(t), cos(t))
}

ggplot() + geom_function_1d_2d(fun = f)

f <- function(t) {
  c(sin(t), t * cos(t))
}

ggplot() +
  geom_function_1d_2d(fun = f, T = 20, tail_point = TRUE)

f <- function(t) {
  x <- sin(t) * (exp(cos(t)) - 2 * cos(4 * t) - (sin(t / 12))^5)
  y <- cos(t) * (exp(cos(t)) - 2 * cos(4 * t) - (sin(t / 12))^5)
  c(x, y)
}

ggplot() +
  geom_function_1d_2d(fun = f, T = 6.5, arrow = NULL, color = "black")

f <- function(t)  c(abs(cos(t)*t), t)

ggplot() + geom_function_1d_2d(fun = f, t0 = -20,  T = 20)

# Lissajous curve
lissajous <- function(t, A = 1, B = 1, a = 3, b = 2, delta = pi/2) {
  c(A * sin(a * t + delta), B * sin(b * t))
}

ggplot() +
  geom_function_1d_2d( fun = lissajous, T = 2 * pi, color = "black", arrow = NULL,
    args = list(A = 1, B = 1, a = 3, b = 2, delta = pi/2)
  )

# Example 5: Variations on Lissajous curves
ggplot() +
  geom_function_1d_2d( fun = lissajous, T = 2 * pi, color = "black", arrow = NULL,
    args = list(A = 2, B = 1, a = 4, b = 2, delta = pi/4)
  )

ggplot() +
  geom_function_1d_2d( fun = lissajous, T = 2 * pi, color = "black", arrow = NULL,
    args = list(A = 1, B = 2, a = 5, b = 3, delta = pi/3)
  )

ggplot() +
  geom_function_1d_2d( fun = lissajous, T = 2 * pi, color = "black", arrow = NULL,
    args = list(A = 0.5, B = 0.5, a = 2, b = 3, delta = pi/6)
  )

ggplot() +
  geom_function_1d_2d( fun = lissajous, T = 2 * pi, color = "black", arrow = NULL,
    args = list(A = 0.5, B = 0.5, a = 5, b = 4, delta = pi/2)
  )

# Harmonic cuves

f <- function(t,
  A1 = 1, A2 = 1, A3 = 1, A4 = 1,
  f1 = 1, f2 = 2, f3 = 3, f4 = 4,
  p1 = 0, p2 = pi/4, p3 = pi/2, p4 = 3*pi/4,
  d1 = 0.1, d2 = 0.2, d3 = 0.3, d4 = 0.4) {
    x <- A1 * sin(t * f1 + p1) * exp(-d1 * t) + A2 * sin(t * f2 + p2) * exp(-d2 * t)
    y <- A3 * sin(t * f3 + p3) * exp(-d3 * t) + A4 * sin(t * f4 + p4) * exp(-d4 * t)
    c(x, y)
}

ggplot() + geom_function_1d_2d(fun = f, t0 = 0,  T = 5)

}
\keyword{datasets}
