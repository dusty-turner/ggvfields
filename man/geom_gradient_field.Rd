% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom_gradient_field.R
\name{geom_gradient_field}
\alias{geom_gradient_field}
\alias{stat_gradient_field}
\alias{geom_gradient_field2}
\alias{stat_gradient_field2}
\title{Gradient Field Layers for ggplot2}
\usage{
stat_gradient_field(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "stream",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  arrow = grid::arrow(angle = 30, length = grid::unit(0.02, "npc"), type = "closed")
)

geom_gradient_field2(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "stream",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  arrow = NULL
)

stat_gradient_field2(
  mapping = NULL,
  data = NULL,
  geom = GeomStream,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = TRUE,
  inherit.aes = TRUE,
  fun,
  xlim = NULL,
  ylim = NULL,
  n = 11,
  max_it = 1000,
  T = NULL,
  L = NULL,
  center = TRUE,
  type = "stream",
  normalize = TRUE,
  tail_point = FALSE,
  eval_point = FALSE,
  grid = NULL,
  arrow = NULL
)
}
\arguments{
\item{mapping}{A set of aesthetic mappings created by \code{\link[ggplot2:aes]{ggplot2::aes()}}.
Additional aesthetics such as \code{color}, \code{size}, \code{linetype}, and \code{alpha} can
be defined. In \strong{geom_gradient_field} the default mapping includes \code{color = after_stat(norm)}, whereas in \strong{geom_gradient_field2} the default
mapping includes \code{length = after_stat(norm)}.}

\item{data}{A data frame containing the input data.}

\item{geom}{The geometric object used to draw the streamline. Defaults to
\link[ggplot2:ggplot2-ggproto]{ggplot2::GeomPath} in \code{geom_stream()}, or \link{GeomStream} in \code{stat_stream()}.}

\item{position}{Position adjustment, either as a string or the result of a
call to a position adjustment function.}

\item{...}{Other arguments passed on to \code{\link[ggplot2:layer]{ggplot2::layer()}}.}

\item{na.rm}{Logical. If \code{FALSE} (the default), missing values are removed
with a warning.}

\item{show.legend}{Logical. Should this layer be included in the legends?}

\item{inherit.aes}{Logical. If \code{FALSE}, overrides the default aesthetics
rather than combining with them.}

\item{fun}{A function that defines the scalar field. It should take a numeric
vector of length 2 (representing \eqn{(x, y)}) and return a single numeric
value. \strong{(Required)}}

\item{xlim}{Numeric vector of length two. Specifies the limits of the x-axis
domain. Defaults to \code{c(-1, 1)}.}

\item{ylim}{Numeric vector of length two. Specifies the limits of the y-axis
domain. Defaults to \code{c(-1, 1)}.}

\item{n}{Integer. Grid resolution specifying the number of seed points along
each axis. Higher values produce a denser gradient field. Defaults to \code{11}.}

\item{max_it}{Integer. Maximum number of integration steps allowed when
computing the gradient stream or vector. Defaults to 1000.}

\item{T}{Numeric. Time increment used for numerical integration when
\code{normalize} is FALSE. If not provided, it is computed automatically based
on grid spacing and the vector field’s magnitude.}

\item{L}{Numeric. Target length for the gradient vectors or streamlines. When
\code{normalize} is TRUE, computed vectors are scaled to have length L. If not
provided, L is computed automatically from the grid spacing.}

\item{center}{Logical. If \code{TRUE}, centers the seed points so that the
original (x, y) becomes the midpoint. Defaults differ between the variants.}

\item{type}{Character. Specifies the type of field to compute: use \code{"stream"}
to generate integrated streamlines or \code{"vector"} for individual vector
segments. Defaults to \code{"stream"}.
gradient vectors. In \strong{geom_gradient_field} the default is a closed arrow
with a 30° angle and length \code{0.02} npc; in \strong{geom_gradient_field2} the
default is \code{NULL}.}

\item{normalize}{Logical. If \code{TRUE}, gradient vectors are normalized based on
grid spacing. If \code{TRUE}, it is converted internally to \code{"vector"}. Default
is \code{TRUE}.}

\item{tail_point}{Logical. If \code{TRUE}, a point is drawn at the tail of each
gradient vector. Defaults differ between the variants.}

\item{eval_point}{Logical. If \code{TRUE}, a point is drawn at the evaluation
point where the gradient was computed. Default is \code{FALSE}.}

\item{grid}{A data frame containing precomputed grid points for seed
placement. If \code{NULL} (default), a regular Cartesian
grid is generated based on \code{xlim}, \code{ylim}, and \code{n}.}

\item{arrow}{A \code{\link[grid:arrow]{grid::arrow()}} specification to add arrowheads to the}

\item{stat}{The statistical transformation to use on the data for this layer.
Defaults to \link{StatStreamField}.}
}
\value{
A ggplot2 layer that computes and plots a gradient field by
numerically differentiating a scalar field.
}
\description{
These functions provide convenient ggplot2 layers for drawing gradient fields
by computing the gradient of a scalar field. A user-defined function (\code{fun})
specifies the behavior of the scalar field by taking a numeric vector of
length 2 (representing \eqn{(x, y)}) and returning a single numeric value.
The underlying \link{StatStreamField} computes the gradient via numerical
differentiation (using \code{\link[numDeriv:grad]{numDeriv::grad()}}) and \link{GeomStream} renders the
resulting vectors.
}
\details{
Two variants are provided:
\itemize{
\item \strong{geom_gradient_field()} uses a default mapping that sets \code{color = after_stat(norm)}.
\item \strong{geom_gradient_field2()} uses a default mapping that sets \code{length = after_stat(norm)} (with \code{color}
unmapped by default).
}
}
\examples{
Si <- matrix(c(1, 0.75, 0.75, 1), nrow = 2)
f <- function(u) exp(-as.numeric(u \%*\% solve(Si) \%*\% u) / 2) / (2 * pi * det(Si))

ggplot() +
  geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3))

df <- expand.grid(x = seq(-3, 3, 0.1), y = seq(-3, 3, 0.1)) |>
  transform(fxy = apply(cbind(x, y), 1, f))

ggplot() +
  geom_raster(aes(x, y, fill = fxy), data = df) +
  geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +
  coord_equal()

fxy <- function(x, y) apply(cbind(x,y), 1, f)

ggplot() +
  ggdensity::geom_hdr_fun(fun = fxy, xlim = c(-3,3), ylim = c(-3,3)) +
  geom_gradient_field(fun = f, xlim = c(-3,3), ylim = c(-3,3)) +
  coord_equal()

\dontrun{
  library("ggdensity")
  fxy <- function(x, y) apply(cbind(x, y), 1, f)
  fxy(1, 2)
  f(1:2)

  ggplot() +
    geom_hdr_fun(fun = fxy, xlim = c(-3, 3), ylim = c(-3, 3)) +
    geom_gradient_field(fun = f, xlim = c(-3, 3), ylim = c(-3, 3)) +
    coord_equal()
}
}
