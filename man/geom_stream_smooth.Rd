% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom_stream_smooth.R
\name{geom_stream_smooth}
\alias{geom_stream_smooth}
\title{Create a Smoothed Vector Field Layer}
\usage{
geom_stream_smooth(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 11,
  xlim = NULL,
  ylim = NULL,
  normalize = TRUE,
  center = FALSE,
  type = "vector",
  formula = cbind(fx, fy) ~ x * y,
  arrow = grid::arrow(angle = 20, length = unit(0.015, "npc"), type = "closed")
)
}
\arguments{
\item{mapping}{A set of aesthetic mappings created by \code{\link[ggplot2:aes]{ggplot2::aes()}}.
\strong{Required:} \code{x} and \code{y} must always be provided. In addition, either
\code{xend} and \code{yend} or \code{angle} and \code{distance} must be supplied.}

\item{data}{A data frame containing the vector data in wide format.}

\item{stat}{The statistical transformation to use on the data for this layer.
Defaults to \link{StatVector}.}

\item{position}{Position adjustment, either as a string or the result of a
call to a position adjustment function.}

\item{...}{Additional arguments passed on to the layer. In addition, if a
fixed parameter \code{color} is not provided via \code{...}, then \code{color = "blue"} is
used.}

\item{na.rm}{Logical. If \code{FALSE} (the default), missing values are removed
with a warning.}

\item{show.legend}{Logical. Should this layer be included in the legends?}

\item{inherit.aes}{Logical. If \code{FALSE}, overrides the default aesthetics
rather than combining with them.}

\item{n}{Integer or two-element numeric vector. Grid resolution specifying
the number of seed points along each axis. Defaults to \code{11}, resulting in
an \eqn{11 \times 11} grid.}

\item{xlim, ylim}{Numeric vectors of length two specifying the domain limits
in the \eqn{x}- and \eqn{y}-directions, respectively. Defaults to
\eqn{c(-1, 1)} if not provided.}

\item{normalize}{Logical. If \code{TRUE}, the vector endpoints are adjusted so
that each vector has unit length.}

\item{center}{Logical. If \code{TRUE}, the vector is recentered so that the
original (x, y) becomes the midpoint of the vector. Default is \code{FALSE}.}

\item{type}{Character. Either \code{"stream"} (default) or \code{"vector"}.
\itemize{
\item \code{"stream"} computes a full streamline by integrating in both directions (when \code{center = TRUE}).
\item \code{"vector"} computes a single vector representing the field at the seed point.
}}

\item{formula}{A formula specifying the multivariate linear model used for
smoothing. Defaults to \code{cbind(fx, fy) ~ x * y}.}

\item{arrow}{An optional \code{\link[grid:arrow]{grid::arrow()}} specification to add arrowheads to
the vectors (default: \code{grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")}).}
}
\value{
A ggplot2 layer that can be added to a ggplot object to display a
smoothed vector field.
}
\description{
\code{geom_stream_smooth} creates a ggplot2 layer that visualizes a smooth vector
field based on raw vector data. The function fits a multivariate linear model
(by default, using the formula \code{cbind(fx, fy) ~ x * y}) to predict the vector
displacements at any given location. It also handles different input formats
by converting polar coordinates or endpoint data to vector displacements.
}
\details{
\strong{Data Conversion:}
If \code{xend}/\code{yend} are missing or all \code{NA}, then the function will attempt to
compute them. First it checks for vector displacements (\code{fx} and \code{fy}); if
these exist (and are not all missing), the endpoints are computed as:
\deqn{xend = x + fx,\quad yend = y + fy.} If not, the function looks for
polar coordinates (\code{angle} and \code{distance}) and computes: \deqn{xend = x +
distance \times \cos(angle \times 180/\pi),\quad yend = y + distance \times
\sin(angle \times 180/\pi).} If neither set is available, the function stops
with an error.

\strong{Smoothing:}
The multivariate linear model is fitted using the provided \code{formula} and
\code{data}. This model is then used to predict vector displacements at any
specified grid point, generating a smooth approximation of the vector field.
}
\section{Aesthetics}{
 \code{geom_stream_smooth} supports the following aesthetics
(required aesthetics are in \strong{bold}):
\itemize{
\item \strong{\code{x}}: The x-coordinate of the vector's starting point.
\item \strong{\code{y}}: The y-coordinate of the vector's starting point.
\item \strong{\code{fx}}: The displacement along the x-axis.
\item \strong{\code{fy}}: The displacement along the y-axis.
\item \code{color}: The fixed color for the vector. Defaults to \code{"blue"}.
\item \code{linewidth}: The thickness of the vector line.
\item \code{linetype}: The type of the vector line (e.g., solid or dashed).
\item \code{alpha}: The transparency level of the vector.
\item \code{arrow}: Specifies arrowheads for the vectors.
}
}

\examples{
generate_vectors <- function(v) {
  x <- v[1]
  y <- v[2]
  c(sin(x) + sin(y) + rnorm(1, 5, 1),
    sin(x) - sin(y) - rnorm(1, 5, 1))
}
# Set seed for reproducibility
set.seed(123)
# Create sample points and compute vectors
sample_points <- data.frame(
  x = runif(30, 0, 10),
  y = runif(30, 0, 10)
)
result <- t(apply(sample_points, 1, generate_vectors))
sample_points$xend <- result[, 1]
sample_points$yend <- result[, 2]
sample_points$fx <- sample_points$xend - sample_points$x
sample_points$fy <- sample_points$yend - sample_points$y
sample_points$distance <- sqrt(sample_points$fx^2 + sample_points$fy^2)
sample_points$angle <- atan2(sample_points$fy, sample_points$fx)
# Define evaluation points
eval_points <- data.frame(
  x = c(0, 7.5),
  y = c(10, 5)
)

p <- ggplot() +
  geom_vector(data = sample_points,
              aes(x = x, y = y, fx = fx, fy = fy),
              color = "black")

p + geom_stream_smooth(formula = cbind(fx, fy) ~ x * y, data = sample_points)
p + geom_stream_smooth(formula = cbind(fx, fy) ~ poly(x,2) * poly(y,2), data = sample_points)

}
