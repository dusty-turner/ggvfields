% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geom_stream_smooth.R
\name{geom_stream_smooth}
\alias{geom_stream_smooth}
\title{Create a Smoothed Vector Field Layer}
\usage{
geom_stream_smooth(
  mapping = NULL,
  data = NULL,
  stat = StatStreamField,
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  n = 11,
  xlim = NULL,
  ylim = NULL,
  normalize = TRUE,
  center = FALSE,
  type = "vector",
  formula = cbind(fx, fy) ~ x * y,
  eval_points = NULL,
  arrow = grid::arrow(angle = 20, length = unit(0.015, "npc"), type = "closed")
)
}
\arguments{
\item{mapping}{A set of aesthetic mappings created by \code{\link[ggplot2:aes]{ggplot2::aes()}}.
\strong{Required:} \code{x} and \code{y} must always be provided. In addition, either
\code{xend} and \code{yend} or \code{angle} and \code{distance} must be supplied.}

\item{data}{A data frame containing the vector data in wide format.}

\item{stat}{The statistical transformation to use on the data for this layer.
Defaults to \link{StatVector}.}

\item{position}{Position adjustment, either as a string or the result of a
call to a position adjustment function.}

\item{...}{Additional arguments passed on to the layer. In addition, if a
fixed parameter \code{color} is not provided via \code{...}, then \code{color = "blue"} is
used.}

\item{na.rm}{Logical. If \code{FALSE} (the default), missing values are removed
with a warning.}

\item{show.legend}{Logical. Should this layer be included in the legends?}

\item{inherit.aes}{Logical. If \code{FALSE}, overrides the default aesthetics
rather than combining with them.}

\item{n}{Integer or two-element numeric vector. Grid resolution specifying
the number of seed points along each axis. Defaults to \code{11}, resulting in
an \eqn{11 \times 11} grid.}

\item{xlim, ylim}{Numeric vectors of length two specifying the domain limits
in the \eqn{x}- and \eqn{y}-directions, respectively. Defaults to
\eqn{c(-1, 1)} if not provided.}

\item{normalize}{Logical. If \code{TRUE}, the vector endpoints are adjusted so
that each vector has unit length.}

\item{center}{Logical. If \code{TRUE}, the vector is recentered so that the
original (x, y) becomes the midpoint of the vector. Default is \code{FALSE}.}

\item{type}{Character. Either \code{"stream"} (default) or \code{"vector"}.
\itemize{
\item \code{"stream"} computes a full streamline by integrating in both directions (when \code{center = TRUE}).
\item \code{"vector"} computes a single vector representing the field at the seed point.
}}

\item{formula}{A formula specifying the multivariate linear model used for
smoothing. Defaults to \code{cbind(fx, fy) ~ x * y}.}

\item{eval_points}{Data frame of evaluation points, or \code{NULL}. When provided,
it specifies the grid points where the smoothing model is evaluated. If
\code{NULL}, the function generates a grid based on \code{n}.}

\item{arrow}{An optional \code{\link[grid:arrow]{grid::arrow()}} specification to add arrowheads to
the vectors (default: \code{grid::arrow(angle = 25, length = unit(0.025, "npc"), type = "closed")}).}
}
\value{
A ggplot2 layer that can be added to a ggplot object to display a
smoothed vector field.
}
\description{
\code{geom_stream_smooth} creates a ggplot2 layer that visualizes a smooth vector
field based on raw vector data. The function fits a multivariate linear model
(by default, using the formula \code{cbind(fx, fy) ~ x * y}) to predict the vector
displacements at any given location. It also handles different input formats
by converting polar coordinates or endpoint data to vector displacements.
}
\details{
\strong{Data Conversion:}
If \code{xend}/\code{yend} are missing or all \code{NA}, then the function will attempt to
compute them. First it checks for vector displacements (\code{fx} and \code{fy}); if
these exist (and are not all missing), the endpoints are computed as:
\deqn{xend = x + fx,\quad yend = y + fy.} If not, the function looks for
polar coordinates (\code{angle} and \code{distance}) and computes: \deqn{xend = x +
distance \times \cos(angle \times 180/\pi),\quad yend = y + distance \times
\sin(angle \times 180/\pi).} If neither set is available, the function stops
with an error.

\strong{Smoothing:}
The multivariate linear model is fitted using the provided \code{formula} and
\code{data}. This model is then used to predict vector displacements at any
specified grid point, generating a smooth approximation of the vector field.
}
\section{Aesthetics}{
 \code{geom_stream_smooth} supports the following aesthetics
(required aesthetics are in \strong{bold}):
\itemize{
\item \strong{\code{x}}: The x-coordinate of the vector's starting point.
\item \strong{\code{y}}: The y-coordinate of the vector's starting point.
\item \strong{\code{fx}}: The displacement along the x-axis.
\item \strong{\code{fy}}: The displacement along the y-axis.
\item \code{color}: The fixed color for the vector. Defaults to \code{"blue"}.
\item \code{linewidth}: The thickness of the vector line.
\item \code{linetype}: The type of the vector line (e.g., solid or dashed).
\item \code{alpha}: The transparency level of the vector.
\item \code{arrow}: Specifies arrowheads for the vectors.
}
}

\examples{
# Define a true vector field function
f <- function(u) {
  x <- u[1]; y <- u[2]
  c(x^2 - y^2, x^2 + y^2 - 2)
}

# Alternative example function
f <- function(u) c(-u[2], u[1])

# Visualize the vector field
ggplot() + geom_stream_field(fun = f, xlim = c(-2, 2), ylim = c(-2, 2))

# Generate design points
n <- 20
df <- data.frame(x = runif(n, -2, 2), y = runif(n, -2, 2))

# Sample function values at design points
fdf <- as.data.frame(t(apply(df, 1, f)))
colnames(fdf) <- c("fx", "fy")
df <- cbind(df, fdf)

# Visualize raw vector field data
ggplot(df) + geom_vector(aes(x, y, fx = fx, fy = fy))

# Add smoothed layer using default model
ggplot(df) +
  geom_vector(aes(x, y, fx = fx, fy = fy)) +
  geom_stream_smooth(formula = cbind(fx, fy) ~ x * y)

# Use a more complex polynomial model
ggplot(df) +
  geom_vector(aes(x, y, fx = fx, fy = fy)) +
  geom_stream_smooth(formula = cbind(fx, fy) ~ poly(x, 2) * poly(y, 2), data = df)

# Fit a linear model and use it for prediction
fhat <- function(u) {
  model <- lm(cbind(fx, fy) ~ x * y, data = df)
  predict(model, newdata = data.frame(x = u[1], y = u[2])) |> as.numeric()
}

# Visualize estimated field with the raw vector field
ggplot(df) +
  geom_stream_field(fun = fhat, normalize = FALSE, color = "#3366FF") +
  geom_vector(aes(x, y, fx = fx, fy = fy))

# Generate a hexagonal grid
hex_lattice <- grid_hex(xlim = c(-5, 5), ylim = c(-5, 5), d = 1)

# Use the hexagonal grid in geom_stream_field
ggplot(data = df) +
  geom_vector(aes(x, y, fx = fx, fy = fy), color = "black", normalize = FALSE) +
  geom_stream_smooth(eval_points = hex_lattice)

# user specified point

eval_pts <- data.frame(x = c(0, 1), y = c(2, -1))

ggplot(data = df) +
  geom_vector(aes(x, y, fx = fx, fy = fy), color = "black", normalize = FALSE) +
  geom_stream_smooth(eval_points = eval_pts)

}
